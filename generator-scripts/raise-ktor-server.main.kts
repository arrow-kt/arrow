@file:DependsOn("me.alllex.parsus:parsus-jvm:0.6.1")

import me.alllex.parsus.parser.Grammar
import me.alllex.parsus.parser.between
import me.alllex.parsus.parser.choose
import me.alllex.parsus.parser.map
import me.alllex.parsus.parser.maybe
import me.alllex.parsus.parser.or
import me.alllex.parsus.parser.parseOrNull
import me.alllex.parsus.parser.parser
import me.alllex.parsus.parser.times
import me.alllex.parsus.parser.unaryMinus
import me.alllex.parsus.token.literalToken
import me.alllex.parsus.token.regexToken
import java.io.File
import java.net.URI
import java.nio.file.Paths
import kotlin.io.path.writer

sealed interface KtorExtension {
  val extensionName: String
  val pathType: String?
}

data class StandardKtorExtension(override val extensionName: String, override val pathType: String?) : KtorExtension
data class ReceivingKtorExtension(override val extensionName: String, override val pathType: String?) : KtorExtension

//region simple abi
object KtorExtensionAbiGrammer : Grammar<KtorExtension>() {
  val funPrefixStandard by literalToken("final fun (io.ktor.server.routing/Route).io.ktor.server.routing/")
  val funPrefixReceiving by literalToken("final inline fun <#A: reified kotlin/Any> (io.ktor.server.routing/Route).io.ktor.server.routing/")

  val funName by regexToken("[a-zA-Z_][a-zA-Z0-9_]*") map { it.text }

  val pathParamType by regexToken("[^,]+") map { it.text.split("/").last() }

  val bodyParamStandard by literalToken("kotlin.coroutines/SuspendFunction1<io.ktor.server.routing/RoutingContext, kotlin/Unit>")
  val bodyParamReceiving by literalToken("crossinline kotlin.coroutines/SuspendFunction2<io.ktor.server.routing/RoutingContext, #A, kotlin/Unit>")
  val bodyParamType by bodyParamStandard or bodyParamReceiving map { it.text }

  val pathAndBody by pathParamType * -literalToken(", ") * bodyParamType map { (path, body) -> path to body }
  val bodyOnly by bodyParamType map { null to it }

  val params by (pathAndBody or bodyOnly)
    .between(literalToken("("), literalToken(")"))

  val returnRoute by -literalToken(": io.ktor.server.routing/Route")
  val trailingComment by -regexToken("\\s+//.+")

  val ktorRoutingExtension by parser {
    val receiving = choose(funPrefixStandard.map { false }, funPrefixReceiving.map { true })

    val name = funName()
    val (pathType, _) = params()
    returnRoute()

    if (receiving) ReceivingKtorExtension(name, pathType)
    else StandardKtorExtension(name, pathType)
  }

  override val root = ktorRoutingExtension * -maybe(trailingComment)

  fun parseDump(abiDump: String): List<KtorExtension> = abiDump.lines()
    .mapNotNull(::parseOrNull)
}
//endregion

//region function rendering
val KtorExtension.jvmNameSuffix
  get() = when (this) {
    is StandardKtorExtension -> ""
    is ReceivingKtorExtension -> "Typed"
  } + when (pathType) {
    null -> ""
    "String" -> "Path"
    else -> pathType
  }

val KtorExtension.jvmName get() = "${extensionName}OrRaise${jvmNameSuffix}"

val KtorExtension.bodyParameter
  get() = when (this) {
    is StandardKtorExtension -> "crossinline body: RespondingRaiseRoutingHandler<TResponse>"
    is ReceivingKtorExtension -> "body: ReceivingRespondingRaiseRoutingHandler<TRequest, TResponse>"
  }

val KtorExtension.typeParameters
  get() = when (this) {
    is StandardKtorExtension -> "<reified TResponse>"
    is ReceivingKtorExtension -> "<reified TRequest : Any, reified TResponse>"
  }

val KtorExtension.invocation
  get() = "$extensionName$invocationParams"

val KtorExtension.invocationParams
  get() = when (pathType) {
    null -> " { respondOrRaise(statusCode, body) }"
    else -> "(path) { respondOrRaise(statusCode, body) }"
  }
//endregion

val dumpFile = File("../build/ktor-server-core.klib.api")
val dumpString = when {
  dumpFile.exists() -> dumpFile.readText()
  else -> URI.create("https://raw.githubusercontent.com/ktorio/ktor/refs/heads/main/ktor-server/ktor-server-core/api/ktor-server-core.klib.api").toURL().readText().also { dumpFile.writeText(it) }
}

KtorExtensionAbiGrammer.parseDump(dumpString)
  .sortedBy(KtorExtension::jvmName)
  .groupBy { it is ReceivingKtorExtension }
  .forEach { (receiving, extensionFunctions) ->
    val destination = Paths.get(
      "../arrow-libs/integrations/arrow-raise-ktor-server",
      "src/commonMain/kotlin/arrow/raise/ktor/server",
      if (receiving) "routingReceiving.kt" else "routing.kt",
    )
    destination.writer().use {
      it.appendLine(
        """
        // Generated by raise-ktor-server.main.kts
        
        package arrow.raise.ktor.server

        import arrow.core.raise.RaiseDSL
        import io.ktor.http.*
        import io.ktor.server.routing.*
        import io.ktor.utils.io.*
        import kotlin.jvm.JvmName
      """.trimIndent()
      )
      extensionFunctions.forEach { extensionFunction ->
        it.appendLine(
          """
            
            @KtorDsl
            @RaiseDSL
            @JvmName("${extensionFunction.jvmName}")
            public inline fun ${extensionFunction.typeParameters} Route.${extensionFunction.extensionName}OrRaise(
          """.trimIndent()
        )
        if (extensionFunction.pathType != null) it.appendLine("  path: ${extensionFunction.pathType},")
        it.appendLine(
          """
              statusCode: HttpStatusCode? = null,
              ${extensionFunction.bodyParameter},
            ): Route = ${extensionFunction.invocation}
          """.trimIndent()
        )
      }
    }
  }
