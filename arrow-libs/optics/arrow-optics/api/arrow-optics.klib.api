// Klib ABI Dump
// Targets: [iosArm64, iosSimulatorArm64, iosX64, js, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, watchosArm32, watchosArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <io.arrow-kt:arrow-optics>
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> arrow.optics.typeclasses/At { // arrow.optics.typeclasses/At|null[0]
    abstract fun at(#B): arrow.optics/PLens<#A, #A, #C, #C> // arrow.optics.typeclasses/At.at|at(1:1){}[0]
    final object Companion { // arrow.optics.typeclasses/At.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics.typeclasses/At<kotlin.collections/Map<#A2, #B2>, #A2, arrow.core/Option<#B2>> // arrow.optics.typeclasses/At.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> set(): arrow.optics.typeclasses/At<kotlin.collections/Set<#A2>, #A2, kotlin/Boolean> // arrow.optics.typeclasses/At.Companion.set|set(){0§<kotlin.Any?>}[0]
    }
    open fun <#A1: kotlin/Any?> (arrow.optics/PLens<#A1, #A1, #A, #A>).at(#B): arrow.optics/PLens<#A1, #A1, #C, #C> // arrow.optics.typeclasses/At.at|at@arrow.optics.PLens<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #A, #A>).at(#B): arrow.optics/POptional<#A1, #A1, #C, #C> // arrow.optics.typeclasses/At.at|at@arrow.optics.POptional<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #A, #A>).at(#B): arrow.optics/PTraversal<#A1, #A1, #C, #C> // arrow.optics.typeclasses/At.at|at@arrow.optics.PTraversal<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> arrow.optics.typeclasses/FilterIndex { // arrow.optics.typeclasses/FilterIndex|null[0]
    abstract fun filter(kotlin/Function1<#B, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, #C, #C> // arrow.optics.typeclasses/FilterIndex.filter|filter(kotlin.Function1<1:1,kotlin.Boolean>){}[0]
    final object Companion { // arrow.optics.typeclasses/FilterIndex.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics.typeclasses/FilterIndex<kotlin.collections/Map<#A2, #B2>, #A2, #B2> // arrow.optics.typeclasses/FilterIndex.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/FilterIndex<kotlin.collections/List<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/FilterIndex.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyList(): arrow.optics.typeclasses/FilterIndex<arrow.core/NonEmptyList<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/FilterIndex.Companion.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> sequence(): arrow.optics.typeclasses/FilterIndex<kotlin.sequences/Sequence<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/FilterIndex.Companion.sequence|sequence(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/FilterIndex<kotlin/String, kotlin/Int, kotlin/Char> // arrow.optics.typeclasses/FilterIndex.Companion.string|string(){}[0]
    }
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> arrow.optics.typeclasses/Index { // arrow.optics.typeclasses/Index|null[0]
    abstract fun index(#B): arrow.optics/POptional<#A, #A, #C, #C> // arrow.optics.typeclasses/Index.index|index(1:1){}[0]
    final object Companion { // arrow.optics.typeclasses/Index.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics.typeclasses/Index<kotlin.collections/Map<#A2, #B2>, #A2, #B2> // arrow.optics.typeclasses/Index.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/Index<kotlin.collections/List<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/Index.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyList(): arrow.optics.typeclasses/Index<arrow.core/NonEmptyList<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/Index.Companion.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> sequence(): arrow.optics.typeclasses/Index<kotlin.sequences/Sequence<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/Index.Companion.sequence|sequence(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/Index<kotlin/String, kotlin/Int, kotlin/Char> // arrow.optics.typeclasses/Index.Companion.string|string(){}[0]
    }
    open fun <#A1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #A, #A>).get(#B): arrow.optics/POptional<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.get|get@arrow.optics.POptional<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #A, #A>).index(#B): arrow.optics/POptional<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.index|index@arrow.optics.POptional<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #A, #A>).get(#B): arrow.optics/PTraversal<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.get|get@arrow.optics.PTraversal<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #A, #A>).index(#B): arrow.optics/PTraversal<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.index|index@arrow.optics.PTraversal<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics.typeclasses/Cons { // arrow.optics.typeclasses/Cons|null[0]
    abstract fun cons(): arrow.optics/PPrism<#A, #A, kotlin/Pair<#B, #A>, kotlin/Pair<#B, #A>> // arrow.optics.typeclasses/Cons.cons|cons(){}[0]
    final object Companion { // arrow.optics.typeclasses/Cons.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> invoke(arrow.optics/PPrism<#A2, #A2, kotlin/Pair<#B2, #A2>, kotlin/Pair<#B2, #A2>>): arrow.optics.typeclasses/Cons<#A2, #B2> // arrow.optics.typeclasses/Cons.Companion.invoke|invoke(arrow.optics.PPrism<0:0,0:0,kotlin.Pair<0:1,0:0>,kotlin.Pair<0:1,0:0>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/Cons<kotlin.collections/List<#A2>, #A2> // arrow.optics.typeclasses/Cons.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/Cons<kotlin/String, kotlin/Char> // arrow.optics.typeclasses/Cons.Companion.string|string(){}[0]
    }
    open fun (#A).uncons(): kotlin/Pair<#B, #A>? // arrow.optics.typeclasses/Cons.uncons|uncons@1:0(){}[0]
    open fun (#B).cons(#A): #A // arrow.optics.typeclasses/Cons.cons|cons@1:1(1:0){}[0]
    open fun firstOption(): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.typeclasses/Cons.firstOption|firstOption(){}[0]
    open fun tailOption(): arrow.optics/POptional<#A, #A, #A, #A> // arrow.optics.typeclasses/Cons.tailOption|tailOption(){}[0]
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics.typeclasses/Snoc { // arrow.optics.typeclasses/Snoc|null[0]
    abstract fun snoc(): arrow.optics/PPrism<#A, #A, kotlin/Pair<#A, #B>, kotlin/Pair<#A, #B>> // arrow.optics.typeclasses/Snoc.snoc|snoc(){}[0]
    final object Companion { // arrow.optics.typeclasses/Snoc.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> invoke(arrow.optics/PPrism<#A2, #A2, kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #B2>>): arrow.optics.typeclasses/Snoc<#A2, #B2> // arrow.optics.typeclasses/Snoc.Companion.invoke|invoke(arrow.optics.PPrism<0:0,0:0,kotlin.Pair<0:0,0:1>,kotlin.Pair<0:0,0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/Snoc<kotlin.collections/List<#A2>, #A2> // arrow.optics.typeclasses/Snoc.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/Snoc<kotlin/String, kotlin/Char> // arrow.optics.typeclasses/Snoc.Companion.string|string(){}[0]
    }
    open fun (#A).snoc(#B): #A // arrow.optics.typeclasses/Snoc.snoc|snoc@1:0(1:1){}[0]
    open fun (#A).unsnoc(): kotlin/Pair<#A, #B>? // arrow.optics.typeclasses/Snoc.unsnoc|unsnoc@1:0(){}[0]
    open fun initOption(): arrow.optics/POptional<#A, #A, #A, #A> // arrow.optics.typeclasses/Snoc.initOption|initOption(){}[0]
    open fun lastOption(): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.typeclasses/Snoc.lastOption|lastOption(){}[0]
    open val init // arrow.optics.typeclasses/Snoc.init|@1:0{}init[0]
        open fun (#A).<get-init>(): #A? // arrow.optics.typeclasses/Snoc.init.<get-init>|<get-init>@1:0(){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PIso : arrow.optics/PLens<#A, #B, #C, #D>, arrow.optics/PPrism<#A, #B, #C, #D> { // arrow.optics/PIso|null[0]
    abstract fun get(#A): #C // arrow.optics/PIso.get|get(1:0){}[0]
    abstract fun reverseGet(#D): #B // arrow.optics/PIso.reverseGet|reverseGet(1:3){}[0]
    final object Companion { // arrow.optics/PIso.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#D2, #B2>): arrow.optics/PIso<#A2, #B2, #C2, #D2> // arrow.optics/PIso.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> listToPOptionNel(): arrow.optics/PIso<kotlin.collections/List<#A2>, kotlin.collections/List<#B2>, arrow.core/Option<arrow.core/NonEmptyList<#A2>>, arrow.core/Option<arrow.core/NonEmptyList<#B2>>> // arrow.optics/PIso.Companion.listToPOptionNel|listToPOptionNel(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> nullableToOption(): arrow.optics/PIso<#A2?, #B2?, arrow.core/Option<#A2>, arrow.core/Option<#B2>> // arrow.optics/PIso.Companion.nullableToOption|nullableToOption(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> nullableToPOption(): arrow.optics/PIso<#A2?, #B2?, arrow.core/Option<#A2>, arrow.core/Option<#B2>> // arrow.optics/PIso.Companion.nullableToPOption|nullableToPOption(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> optionToPEither(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#B2>, arrow.core/Either<kotlin/Unit, #A2>, arrow.core/Either<kotlin/Unit, #B2>> // arrow.optics/PIso.Companion.optionToPEither|optionToPEither(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> optionToPNullable(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#B2>, #A2?, #B2?> // arrow.optics/PIso.Companion.optionToPNullable|optionToPNullable(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PIso.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> listToOptionNel(): arrow.optics/PIso<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, arrow.core/Option<arrow.core/NonEmptyList<#A2>>, arrow.core/Option<arrow.core/NonEmptyList<#A2>>> // arrow.optics/PIso.Companion.listToOptionNel|listToOptionNel(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> mapToSet(): arrow.optics/PIso<kotlin.collections/Map<#A2, kotlin/Unit>, kotlin.collections/Map<#A2, kotlin/Unit>, kotlin.collections/Set<#A2>, kotlin.collections/Set<#A2>> // arrow.optics/PIso.Companion.mapToSet|mapToSet(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> optionToEither(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#A2>, arrow.core/Either<kotlin/Unit, #A2>, arrow.core/Either<kotlin/Unit, #A2>> // arrow.optics/PIso.Companion.optionToEither|optionToEither(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> optionToNullable(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#A2>, #A2?, #A2?> // arrow.optics/PIso.Companion.optionToNullable|optionToNullable(){0§<kotlin.Any?>}[0]
        final fun stringToList(): arrow.optics/PIso<kotlin/String, kotlin/String, kotlin.collections/List<kotlin/Char>, kotlin.collections/List<kotlin/Char>> // arrow.optics/PIso.Companion.stringToList|stringToList(){}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?, #D1: kotlin/Any?> split(arrow.optics/PIso<#A1, #B1, #C1, #D1>): arrow.optics/PIso<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #B1>, kotlin/Pair<#C, #C1>, kotlin/Pair<#D, #D1>> // arrow.optics/PIso.split|split(arrow.optics.PIso<0:0,0:1,0:2,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PIso<in #C, out #D, out #A1, in #B1>): arrow.optics/PIso<#A, #B, #A1, #B1> // arrow.optics/PIso.compose|compose(arrow.optics.PIso<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PIso<in #C, out #D, out #A1, in #B1>): arrow.optics/PIso<#A, #B, #A1, #B1> // arrow.optics/PIso.plus|plus(arrow.optics.PIso<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/PIso<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/PIso.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PIso.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> left(): arrow.optics/PIso<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #A1>, arrow.core/Either<#C, #A1>, arrow.core/Either<#D, #A1>> // arrow.optics/PIso.left|left(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> right(): arrow.optics/PIso<arrow.core/Either<#A1, #A>, arrow.core/Either<#A1, #B>, arrow.core/Either<#A1, #C>, arrow.core/Either<#A1, #D>> // arrow.optics/PIso.right|right(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/PIso<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/PIso.second|second(){0§<kotlin.Any?>}[0]
    open fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/PIso.getOrModify|getOrModify(1:0){}[0]
    open fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/PIso.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun reverse(): arrow.optics/PIso<#D, #C, #B, #A> // arrow.optics/PIso.reverse|reverse(){}[0]
    open fun set(#A, #D): #B // arrow.optics/PIso.set|set(1:0;1:3){}[0]
    open fun set(#D): #B // arrow.optics/PIso.set|set(1:3){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PLens : arrow.optics/POptional<#A, #B, #C, #D> { // arrow.optics/PLens|null[0]
    abstract fun get(#A): #C // arrow.optics/PLens.get|get(1:0){}[0]
    abstract fun set(#A, #D): #B // arrow.optics/PLens.set|set(1:0;1:3){}[0]
    final object Companion { // arrow.optics/PLens.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function2<#A2, #D2, #B2>): arrow.optics/PLens<#A2, #B2, #C2, #D2> // arrow.optics/PLens.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function2<0:0,0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> triplePFirst(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#D2, #B2, #C2>, #A2, #D2> // arrow.optics/PLens.Companion.triplePFirst|triplePFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> triplePSecond(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #D2, #C2>, #B2, #D2> // arrow.optics/PLens.Companion.triplePSecond|triplePSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> triplePThird(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #D2>, #C2, #D2> // arrow.optics/PLens.Companion.triplePThird|triplePThird(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pairPFirst(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#C2, #B2>, #A2, #C2> // arrow.optics/PLens.Companion.pairPFirst|pairPFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pairPSecond(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #C2>, #B2, #C2> // arrow.optics/PLens.Companion.pairPSecond|pairPSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> tripleFirst(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #C2>, #A2, #A2> // arrow.optics/PLens.Companion.tripleFirst|tripleFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> tripleSecond(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #C2>, #B2, #B2> // arrow.optics/PLens.Companion.tripleSecond|tripleSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> tripleThird(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #C2>, #C2, #C2> // arrow.optics/PLens.Companion.tripleThird|tripleThird(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pairFirst(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #B2>, #A2, #A2> // arrow.optics/PLens.Companion.pairFirst|pairFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pairSecond(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #B2>, #B2, #B2> // arrow.optics/PLens.Companion.pairSecond|pairSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> codiagonal(): arrow.optics/PLens<arrow.core/Either<#A2, #A2>, arrow.core/Either<#A2, #A2>, #A2, #A2> // arrow.optics/PLens.Companion.codiagonal|codiagonal(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PLens.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyListHead(): arrow.optics/PLens<arrow.core/NonEmptyList<#A2>, arrow.core/NonEmptyList<#A2>, #A2, #A2> // arrow.optics/PLens.Companion.nonEmptyListHead|nonEmptyListHead(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyListTail(): arrow.optics/PLens<arrow.core/NonEmptyList<#A2>, arrow.core/NonEmptyList<#A2>, kotlin.collections/List<#A2>, kotlin.collections/List<#A2>> // arrow.optics/PLens.Companion.nonEmptyListTail|nonEmptyListTail(){0§<kotlin.Any?>}[0]
        final fun stringToList(): arrow.optics/PLens<kotlin/String, kotlin/String, kotlin.collections/List<kotlin/Char>, kotlin.collections/List<kotlin/Char>> // arrow.optics/PLens.Companion.stringToList|stringToList(){}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?, #D1: kotlin/Any?> split(arrow.optics/PLens<#A1, #B1, #C1, #D1>): arrow.optics/PLens<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #B1>, kotlin/Pair<#C, #C1>, kotlin/Pair<#D, #D1>> // arrow.optics/PLens.split|split(arrow.optics.PLens<0:0,0:1,0:2,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> choice(arrow.optics/PLens<#A1, #B1, #C, #D>): arrow.optics/PLens<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #B1>, #C, #D> // arrow.optics/PLens.choice|choice(arrow.optics.PLens<0:0,0:1,1:2,1:3>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PLens<in #C, out #D, out #A1, in #B1>): arrow.optics/PLens<#A, #B, #A1, #B1> // arrow.optics/PLens.compose|compose(arrow.optics.PLens<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PLens<in #C, out #D, out #A1, in #B1>): arrow.optics/PLens<#A, #B, #A1, #B1> // arrow.optics/PLens.plus|plus(arrow.optics.PLens<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/PLens<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/PLens.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PLens.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/PLens<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/PLens.second|second(){0§<kotlin.Any?>}[0]
    open fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/PLens.getOrModify|getOrModify(1:0){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/POptional : arrow.optics/PTraversal<#A, #B, #C, #D> { // arrow.optics/POptional|null[0]
    abstract fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/POptional.getOrModify|getOrModify(1:0){}[0]
    abstract fun set(#A, #D): #B // arrow.optics/POptional.set|set(1:0;1:3){}[0]
    final object Companion { // arrow.optics/POptional.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, arrow.core/Either<#B2, #C2>>, kotlin/Function2<#A2, #D2, #B2>): arrow.optics/POptional<#A2, #B2, #C2, #D2> // arrow.optics/POptional.Companion.invoke|invoke(kotlin.Function1<0:0,arrow.core.Either<0:1,0:2>>;kotlin.Function2<0:0,0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> void(): arrow.optics/POptional<#A2, #A2, #B2, #B2> // arrow.optics/POptional.Companion.void|void(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> codiagonal(): arrow.optics/POptional<arrow.core/Either<#A2, #A2>, arrow.core/Either<#A2, #A2>, #A2, #A2> // arrow.optics/POptional.Companion.codiagonal|codiagonal(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/POptional.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> listHead(): arrow.optics/POptional<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, #A2, #A2> // arrow.optics/POptional.Companion.listHead|listHead(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> listTail(): arrow.optics/POptional<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, kotlin.collections/List<#A2>> // arrow.optics/POptional.Companion.listTail|listTail(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> notNull(): arrow.optics/POptional<#A2?, #A2?, #A2, #A2> // arrow.optics/POptional.Companion.notNull|notNull(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nullable(): arrow.optics/POptional<#A2?, #A2?, #A2, #A2> // arrow.optics/POptional.Companion.nullable|nullable(){0§<kotlin.Any?>}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> choice(arrow.optics/POptional<#A1, #B1, #C, #D>): arrow.optics/POptional<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #B1>, #C, #D> // arrow.optics/POptional.choice|choice(arrow.optics.POptional<0:0,0:1,1:2,1:3>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/POptional<in #C, out #D, out #A1, in #B1>): arrow.optics/POptional<#A, #B, #A1, #B1> // arrow.optics/POptional.compose|compose(arrow.optics.POptional<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/POptional<in #C, out #D, out #A1, in #B1>): arrow.optics/POptional<#A, #B, #A1, #B1> // arrow.optics/POptional.plus|plus(arrow.optics.POptional<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/POptional<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/POptional.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/POptional.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/POptional<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/POptional.second|second(){0§<kotlin.Any?>}[0]
    open fun getOrNull(#A): #C? // arrow.optics/POptional.getOrNull|getOrNull(1:0){}[0]
    open fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/POptional.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun modifyNullable(#A, kotlin/Function1<#C, #D>): #B? // arrow.optics/POptional.modifyNullable|modifyNullable(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun setNullable(#A, #D): #B? // arrow.optics/POptional.setNullable|setNullable(1:0;1:3){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PPrism : arrow.optics/POptional<#A, #B, #C, #D> { // arrow.optics/PPrism|null[0]
    abstract fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/PPrism.getOrModify|getOrModify(1:0){}[0]
    abstract fun reverseGet(#D): #B // arrow.optics/PPrism.reverseGet|reverseGet(1:3){}[0]
    final object Companion { // arrow.optics/PPrism.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, arrow.core/Either<#B2, #C2>>, kotlin/Function1<#D2, #B2>): arrow.optics/PPrism<#A2, #B2, #C2, #D2> // arrow.optics/PPrism.Companion.invoke|invoke(kotlin.Function1<0:0,arrow.core.Either<0:1,0:2>>;kotlin.Function1<0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pLeft(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#C2, #B2>, #A2, #C2> // arrow.optics/PPrism.Companion.pLeft|pLeft(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pRight(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #C2>, #B2, #C2> // arrow.optics/PPrism.Companion.pRight|pRight(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> left(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #B2>, #A2, #A2> // arrow.optics/PPrism.Companion.left|left(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pSome(): arrow.optics/PPrism<arrow.core/Option<#A2>, arrow.core/Option<#B2>, #A2, #B2> // arrow.optics/PPrism.Companion.pSome|pSome(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> right(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #B2>, #B2, #B2> // arrow.optics/PPrism.Companion.right|right(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PPrism.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> none(): arrow.optics/PPrism<arrow.core/Option<#A2>, arrow.core/Option<#A2>, kotlin/Unit, kotlin/Unit> // arrow.optics/PPrism.Companion.none|none(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> only(#A2, kotlin/Function2<#A2, #A2, kotlin/Boolean> = ...): arrow.optics/PPrism<#A2, #A2, kotlin/Unit, kotlin/Unit> // arrow.optics/PPrism.Companion.only|only(0:0;kotlin.Function2<0:0,0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> some(): arrow.optics/PPrism<arrow.core/Option<#A2>, arrow.core/Option<#A2>, #A2, #A2> // arrow.optics/PPrism.Companion.some|some(){0§<kotlin.Any?>}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PPrism<in #C, out #D, out #A1, in #B1>): arrow.optics/PPrism<#A, #B, #A1, #B1> // arrow.optics/PPrism.compose|compose(arrow.optics.PPrism<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PPrism<in #C, out #D, out #A1, in #B1>): arrow.optics/PPrism<#A, #B, #A1, #B1> // arrow.optics/PPrism.plus|plus(arrow.optics.PPrism<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/PPrism<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/PPrism.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PPrism.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> left(): arrow.optics/PPrism<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #A1>, arrow.core/Either<#C, #A1>, arrow.core/Either<#D, #A1>> // arrow.optics/PPrism.left|left(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> right(): arrow.optics/PPrism<arrow.core/Either<#A1, #A>, arrow.core/Either<#A1, #B>, arrow.core/Either<#A1, #C>, arrow.core/Either<#A1, #D>> // arrow.optics/PPrism.right|right(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/PPrism<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/PPrism.second|second(){0§<kotlin.Any?>}[0]
    open fun liftNullable(kotlin/Function1<#C, #D>): kotlin/Function1<#A, #B?> // arrow.optics/PPrism.liftNullable|liftNullable(kotlin.Function1<1:2,1:3>){}[0]
    open fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/PPrism.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun set(#A, #D): #B // arrow.optics/PPrism.set|set(1:0;1:3){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PTraversal { // arrow.optics/PTraversal|null[0]
    abstract fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PTraversal.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    abstract fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/PTraversal.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    final object Companion { // arrow.optics/PTraversal.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function10<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function10<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function11<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function11<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function9<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function9<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function8<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function8<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function7<#D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function7<0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function6<#D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function6<0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function5<#D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function5<0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function4<#D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function4<0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function3<#D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function3<0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> either(): arrow.optics/PTraversal<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #B2>, #B2, #B2> // arrow.optics/PTraversal.Companion.either|either(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics/PTraversal<kotlin.collections/Map<#A2, #B2>, kotlin.collections/Map<#A2, #B2>, #B2, #B2> // arrow.optics/PTraversal.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pPair(): arrow.optics/PTraversal<kotlin/Pair<#A2, #A2>, kotlin/Pair<#B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pPair|pPair(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTriple(): arrow.optics/PTraversal<kotlin/Triple<#A2, #A2, #A2>, kotlin/Triple<#B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTriple|pTriple(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple4(): arrow.optics/PTraversal<arrow.core/Tuple4<#A2, #A2, #A2, #A2>, arrow.core/Tuple4<#B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple4|pTuple4(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple5(): arrow.optics/PTraversal<arrow.core/Tuple5<#A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple5<#B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple5|pTuple5(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple6(): arrow.optics/PTraversal<arrow.core/Tuple6<#A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple6<#B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple6|pTuple6(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple7(): arrow.optics/PTraversal<arrow.core/Tuple7<#A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple7<#B2, #B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple7|pTuple7(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple8(): arrow.optics/PTraversal<arrow.core/Tuple8<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple8<#B2, #B2, #B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple8|pTuple8(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple9(): arrow.optics/PTraversal<arrow.core/Tuple9<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple9<#B2, #B2, #B2, #B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple9|pTuple9(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> void(): arrow.optics/PTraversal<#A2, #A2, #B2, #B2> // arrow.optics/PTraversal.Companion.void|void(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> codiagonal(): arrow.optics/PTraversal<arrow.core/Either<#A2, #A2>, arrow.core/Either<#A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.codiagonal|codiagonal(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PTraversal.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics/PTraversal<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyList(): arrow.optics/PTraversal<arrow.core/NonEmptyList<#A2>, arrow.core/NonEmptyList<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> option(): arrow.optics/PTraversal<arrow.core/Option<#A2>, arrow.core/Option<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.option|option(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> pair(): arrow.optics/PTraversal<kotlin/Pair<#A2, #A2>, kotlin/Pair<#A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.pair|pair(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> sequence(): arrow.optics/PTraversal<kotlin.sequences/Sequence<#A2>, kotlin.sequences/Sequence<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.sequence|sequence(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> triple(): arrow.optics/PTraversal<kotlin/Triple<#A2, #A2, #A2>, kotlin/Triple<#A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.triple|triple(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple4(): arrow.optics/PTraversal<arrow.core/Tuple4<#A2, #A2, #A2, #A2>, arrow.core/Tuple4<#A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple4|tuple4(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple5(): arrow.optics/PTraversal<arrow.core/Tuple5<#A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple5<#A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple5|tuple5(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple6(): arrow.optics/PTraversal<arrow.core/Tuple6<#A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple6<#A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple6|tuple6(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple7(): arrow.optics/PTraversal<arrow.core/Tuple7<#A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple7<#A2, #A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple7|tuple7(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple8(): arrow.optics/PTraversal<arrow.core/Tuple8<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple8<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple8|tuple8(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple9(): arrow.optics/PTraversal<arrow.core/Tuple9<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple9<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple9|tuple9(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics/PTraversal<kotlin/String, kotlin/String, kotlin/Char, kotlin/Char> // arrow.optics/PTraversal.Companion.string|string(){}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> choice(arrow.optics/PTraversal<#A1, #B1, #C, #D>): arrow.optics/PTraversal<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #B1>, #C, #D> // arrow.optics/PTraversal.choice|choice(arrow.optics.PTraversal<0:0,0:1,1:2,1:3>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PTraversal<in #C, out #D, out #A1, in #B1>): arrow.optics/PTraversal<#A, #B, #A1, #B1> // arrow.optics/PTraversal.compose|compose(arrow.optics.PTraversal<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PTraversal<in #C, out #D, out #A1, in #B1>): arrow.optics/PTraversal<#A, #B, #A1, #B1> // arrow.optics/PTraversal.plus|plus(arrow.optics.PTraversal<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun all(#A, kotlin/Function1<#C, kotlin/Boolean>): kotlin/Boolean // arrow.optics/PTraversal.all|all(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun any(#A, kotlin/Function1<#C, kotlin/Boolean>): kotlin/Boolean // arrow.optics/PTraversal.any|any(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun exists(#A, kotlin/Function1<#C, kotlin/Boolean>): kotlin/Boolean // arrow.optics/PTraversal.exists|exists(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun findOrNull(#A, kotlin/Function1<#C, kotlin/Boolean>): #C? // arrow.optics/PTraversal.findOrNull|findOrNull(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun firstOrNull(#A): #C? // arrow.optics/PTraversal.firstOrNull|firstOrNull(1:0){}[0]
    open fun fold(#C, kotlin/Function2<#C, #C, #C>, #A): #C // arrow.optics/PTraversal.fold|fold(1:2;kotlin.Function2<1:2,1:2,1:2>;1:0){}[0]
    open fun getAll(#A): kotlin.collections/List<#C> // arrow.optics/PTraversal.getAll|getAll(1:0){}[0]
    open fun isEmpty(#A): kotlin/Boolean // arrow.optics/PTraversal.isEmpty|isEmpty(1:0){}[0]
    open fun isNotEmpty(#A): kotlin/Boolean // arrow.optics/PTraversal.isNotEmpty|isNotEmpty(1:0){}[0]
    open fun lastOrNull(#A): #C? // arrow.optics/PTraversal.lastOrNull|lastOrNull(1:0){}[0]
    open fun lift(kotlin/Function1<#C, #D>): kotlin/Function1<#A, #B> // arrow.optics/PTraversal.lift|lift(kotlin.Function1<1:2,1:3>){}[0]
    open fun set(#A, #D): #B // arrow.optics/PTraversal.set|set(1:0;1:3){}[0]
    open fun size(#A): kotlin/Int // arrow.optics/PTraversal.size|size(1:0){}[0]
}
abstract interface <#A: kotlin/Any?> arrow.optics/Copy { // arrow.optics/Copy|null[0]
    abstract fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #A1, #A1>).set(#A1) // arrow.optics/Copy.set|set@arrow.optics.PTraversal<1:0,1:0,0:0,0:0>(0:0){0§<kotlin.Any?>}[0]
    abstract fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #A1, #A1>).transform(kotlin/Function1<#A1, #A1>) // arrow.optics/Copy.transform|transform@arrow.optics.PTraversal<1:0,1:0,0:0,0:0>(kotlin.Function1<0:0,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> inside(arrow.optics/PTraversal<#A, #A, #A1, #A1>, kotlin/Function1<arrow.optics/Copy<#A1>, kotlin/Unit>) // arrow.optics/Copy.inside|inside(arrow.optics.PTraversal<1:0,1:0,0:0,0:0>;kotlin.Function1<arrow.optics.Copy<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
}
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/PLens<#A, #A, #B, #B>).arrow.optics.dsl/at(arrow.optics.typeclasses/At<#B, #C, #D>, #C): arrow.optics/PLens<#A, #A, #D, #D> // arrow.optics.dsl/at|at@arrow.optics.PLens<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.At<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.dsl/at(arrow.optics.typeclasses/At<#B, #C, #D>, #C): arrow.optics/POptional<#A, #A, #D, #D> // arrow.optics.dsl/at|at@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.At<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.dsl/index(arrow.optics.typeclasses/Index<#B, #C, #D>, #C): arrow.optics/POptional<#A, #A, #D, #D> // arrow.optics.dsl/index|index@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.Index<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #B, #B>).arrow.optics.dsl/at(arrow.optics.typeclasses/At<#B, #C, #D>, #C): arrow.optics/PTraversal<#A, #A, #D, #D> // arrow.optics.dsl/at|at@arrow.optics.PTraversal<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.At<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #B, #B>).arrow.optics.dsl/index(arrow.optics.typeclasses/Index<#B, #C, #D>, #C): arrow.optics/PTraversal<#A, #A, #D, #D> // arrow.optics.dsl/index|index@arrow.optics.PTraversal<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.Index<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics.typeclasses/At<#A, #B, arrow.core/Option<#C>>).arrow.optics.typeclasses/remove(#A, #B): #A // arrow.optics.typeclasses/remove|remove@arrow.optics.typeclasses.At<0:0,0:1,arrow.core.Option<0:2>>(0:0;0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics.typeclasses/At<#A, #B, arrow.core/Option<#C>>).arrow.optics.typeclasses/remove(#B): kotlin/Function1<#A, #A> // arrow.optics.typeclasses/remove|remove@arrow.optics.typeclasses.At<0:0,0:1,arrow.core.Option<0:2>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #B, #B>).arrow.optics.dsl/every(arrow.optics/PTraversal<#B, #B, #C, #C>): arrow.optics/PTraversal<#A, #A, #C, #C> // arrow.optics.dsl/every|every@arrow.optics.PTraversal<0:0,0:0,0:1,0:1>(arrow.optics.PTraversal<0:1,0:1,0:2,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PLens<#B, #B, kotlin.collections/List<#A>, kotlin.collections/List<#A>>).arrow.optics/get(kotlin/Int): arrow.optics/POptional<#B, #B, #A, #A> // arrow.optics/get|get@arrow.optics.PLens<0:1,0:1,kotlin.collections.List<0:0>,kotlin.collections.List<0:0>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics/Optional(kotlin/Function1<#A, arrow.core/Option<#B>>, kotlin/Function2<#A, #B, #A>): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics/Optional|Optional(kotlin.Function1<0:0,arrow.core.Option<0:1>>;kotlin.Function2<0:0,0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics/Prism(kotlin/Function1<#A, arrow.core/Option<#B>>, kotlin/Function1<#B, #A>): arrow.optics/PPrism<#A, #A, #B, #B> // arrow.optics/Prism|Prism(kotlin.Function1<0:0,arrow.core.Option<0:1>>;kotlin.Function1<0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (#A).arrow.optics/cons(kotlin.collections/List<#A>): kotlin.collections/List<#A> // arrow.optics/cons|cons@0:0(kotlin.collections.List<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (#A).arrow.optics/copy(kotlin/Function1<arrow.optics/Copy<#A>, kotlin/Unit>): #A // arrow.optics/copy|copy@0:0(kotlin.Function1<arrow.optics.Copy<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/List<#A>).arrow.optics/snoc(#A): kotlin.collections/List<#A> // arrow.optics/snoc|snoc@kotlin.collections.List<0:0>(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/List<#A>).arrow.optics/uncons(): kotlin/Pair<#A, kotlin.collections/List<#A>>? // arrow.optics/uncons|uncons@kotlin.collections.List<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/List<#A>).arrow.optics/unsnoc(): kotlin/Pair<kotlin.collections/List<#A>, #A>? // arrow.optics/unsnoc|unsnoc@kotlin.collections.List<0:0>(){0§<kotlin.Any?>}[0]
final object arrow.optics/Every { // arrow.optics/Every|null[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> either(): arrow.optics/PTraversal<arrow.core/Either<#A1, #B1>, arrow.core/Either<#A1, #B1>, #B1, #B1> // arrow.optics/Every.either|either(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> map(): arrow.optics/PTraversal<kotlin.collections/Map<#A1, #B1>, kotlin.collections/Map<#A1, #B1>, #B1, #B1> // arrow.optics/Every.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> list(): arrow.optics/PTraversal<kotlin.collections/List<#A1>, kotlin.collections/List<#A1>, #A1, #A1> // arrow.optics/Every.list|list(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> nonEmptyList(): arrow.optics/PTraversal<arrow.core/NonEmptyList<#A1>, arrow.core/NonEmptyList<#A1>, #A1, #A1> // arrow.optics/Every.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> option(): arrow.optics/PTraversal<arrow.core/Option<#A1>, arrow.core/Option<#A1>, #A1, #A1> // arrow.optics/Every.option|option(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> pair(): arrow.optics/PTraversal<kotlin/Pair<#A1, #A1>, kotlin/Pair<#A1, #A1>, #A1, #A1> // arrow.optics/Every.pair|pair(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> sequence(): arrow.optics/PTraversal<kotlin.sequences/Sequence<#A1>, kotlin.sequences/Sequence<#A1>, #A1, #A1> // arrow.optics/Every.sequence|sequence(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> triple(): arrow.optics/PTraversal<kotlin/Triple<#A1, #A1, #A1>, kotlin/Triple<#A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.triple|triple(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple4(): arrow.optics/PTraversal<arrow.core/Tuple4<#A1, #A1, #A1, #A1>, arrow.core/Tuple4<#A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple4|tuple4(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple5(): arrow.optics/PTraversal<arrow.core/Tuple5<#A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple5<#A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple5|tuple5(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple6(): arrow.optics/PTraversal<arrow.core/Tuple6<#A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple6<#A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple6|tuple6(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple7(): arrow.optics/PTraversal<arrow.core/Tuple7<#A1, #A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple7<#A1, #A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple7|tuple7(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple8(): arrow.optics/PTraversal<arrow.core/Tuple8<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple8<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple8|tuple8(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple9(): arrow.optics/PTraversal<arrow.core/Tuple9<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple9<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple9|tuple9(){0§<kotlin.Any?>}[0]
    final fun string(): arrow.optics/PTraversal<kotlin/String, kotlin/String, kotlin/Char, kotlin/Char> // arrow.optics/Every.string|string(){}[0]
}
final val arrow.optics.dsl/left // arrow.optics.dsl/left|@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}left[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-left>(): arrow.optics/POptional<#A1, #A1, #B1, #B1> // arrow.optics.dsl/left.<get-left>|<get-left>@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/left // arrow.optics.dsl/left|@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}left[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PPrism<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-left>(): arrow.optics/PPrism<#A1, #A1, #B1, #B1> // arrow.optics.dsl/left.<get-left>|<get-left>@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/left // arrow.optics.dsl/left|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}left[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-left>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/left.<get-left>|<get-left>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/notNull // arrow.optics.dsl/notNull|@arrow.optics.POptional<0:0,0:0,0:1?,0:1?>{0§<kotlin.Any?>;1§<kotlin.Any?>}notNull[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #B1?, #B1?>).<get-notNull>(): arrow.optics/POptional<#A1, #A1, #B1, #B1> // arrow.optics.dsl/notNull.<get-notNull>|<get-notNull>@arrow.optics.POptional<0:0,0:0,0:1?,0:1?>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/notNull // arrow.optics.dsl/notNull|@arrow.optics.PTraversal<0:0,0:0,0:1?,0:1?>{0§<kotlin.Any?>;1§<kotlin.Any?>}notNull[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #B1?, #B1?>).<get-notNull>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/notNull.<get-notNull>|<get-notNull>@arrow.optics.PTraversal<0:0,0:0,0:1?,0:1?>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/right // arrow.optics.dsl/right|@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}right[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-right>(): arrow.optics/POptional<#A1, #A1, #C1, #C1> // arrow.optics.dsl/right.<get-right>|<get-right>@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/right // arrow.optics.dsl/right|@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}right[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PPrism<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-right>(): arrow.optics/PPrism<#A1, #A1, #C1, #C1> // arrow.optics.dsl/right.<get-right>|<get-right>@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/right // arrow.optics.dsl/right|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}right[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-right>(): arrow.optics/PTraversal<#A1, #A1, #C1, #C1> // arrow.optics.dsl/right.<get-right>|<get-right>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/some // arrow.optics.dsl/some|@arrow.optics.POptional<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}some[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, arrow.core/Option<#B1>, arrow.core/Option<#B1>>).<get-some>(): arrow.optics/POptional<#A1, #A1, #B1, #B1> // arrow.optics.dsl/some.<get-some>|<get-some>@arrow.optics.POptional<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/some // arrow.optics.dsl/some|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}some[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Option<#B1>, arrow.core/Option<#B1>>).<get-some>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/some.<get-some>|<get-some>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
open annotation class arrow.optics/OpticsCopyMarker : kotlin/Annotation { // arrow.optics/OpticsCopyMarker|null[0]
    constructor <init>() // arrow.optics/OpticsCopyMarker.<init>|<init>(){}[0]
}
