// Klib ABI Dump
// Targets: [iosArm64, iosSimulatorArm64, iosX64, js, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, watchosArm32, watchosArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <io.arrow-kt:arrow-optics>
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> arrow.optics.typeclasses/At { // arrow.optics.typeclasses/At|null[0]
    abstract fun at(#B): arrow.optics/PLens<#A, #A, #C, #C> // arrow.optics.typeclasses/At.at|at(1:1){}[0]
    final object Companion { // arrow.optics.typeclasses/At.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics.typeclasses/At<kotlin.collections/Map<#A2, #B2>, #A2, arrow.core/Option<#B2>> // arrow.optics.typeclasses/At.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> set(): arrow.optics.typeclasses/At<kotlin.collections/Set<#A2>, #A2, kotlin/Boolean> // arrow.optics.typeclasses/At.Companion.set|set(){0§<kotlin.Any?>}[0]
    }
    open fun <#A1: kotlin/Any?> (arrow.optics/PLens<#A1, #A1, #A, #A>).at(#B): arrow.optics/PLens<#A1, #A1, #C, #C> // arrow.optics.typeclasses/At.at|at@arrow.optics.PLens<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #A, #A>).at(#B): arrow.optics/POptional<#A1, #A1, #C, #C> // arrow.optics.typeclasses/At.at|at@arrow.optics.POptional<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #A, #A>).at(#B): arrow.optics/PTraversal<#A1, #A1, #C, #C> // arrow.optics.typeclasses/At.at|at@arrow.optics.PTraversal<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> arrow.optics.typeclasses/FilterIndex { // arrow.optics.typeclasses/FilterIndex|null[0]
    abstract fun filter(kotlin/Function1<#B, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, #C, #C> // arrow.optics.typeclasses/FilterIndex.filter|filter(kotlin.Function1<1:1,kotlin.Boolean>){}[0]
    final object Companion { // arrow.optics.typeclasses/FilterIndex.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics.typeclasses/FilterIndex<kotlin.collections/Map<#A2, #B2>, #A2, #B2> // arrow.optics.typeclasses/FilterIndex.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/FilterIndex<kotlin.collections/List<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/FilterIndex.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyList(): arrow.optics.typeclasses/FilterIndex<arrow.core/NonEmptyList<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/FilterIndex.Companion.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> sequence(): arrow.optics.typeclasses/FilterIndex<kotlin.sequences/Sequence<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/FilterIndex.Companion.sequence|sequence(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/FilterIndex<kotlin/String, kotlin/Int, kotlin/Char> // arrow.optics.typeclasses/FilterIndex.Companion.string|string(){}[0]
    }
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> arrow.optics.typeclasses/Index { // arrow.optics.typeclasses/Index|null[0]
    abstract fun index(#B): arrow.optics/POptional<#A, #A, #C, #C> // arrow.optics.typeclasses/Index.index|index(1:1){}[0]
    final object Companion { // arrow.optics.typeclasses/Index.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics.typeclasses/Index<kotlin.collections/Map<#A2, #B2>, #A2, #B2> // arrow.optics.typeclasses/Index.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/Index<kotlin.collections/List<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/Index.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyList(): arrow.optics.typeclasses/Index<arrow.core/NonEmptyList<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/Index.Companion.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> sequence(): arrow.optics.typeclasses/Index<kotlin.sequences/Sequence<#A2>, kotlin/Int, #A2> // arrow.optics.typeclasses/Index.Companion.sequence|sequence(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/Index<kotlin/String, kotlin/Int, kotlin/Char> // arrow.optics.typeclasses/Index.Companion.string|string(){}[0]
    }
    open fun <#A1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #A, #A>).get(#B): arrow.optics/POptional<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.get|get@arrow.optics.POptional<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #A, #A>).index(#B): arrow.optics/POptional<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.index|index@arrow.optics.POptional<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #A, #A>).get(#B): arrow.optics/PTraversal<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.get|get@arrow.optics.PTraversal<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #A, #A>).index(#B): arrow.optics/PTraversal<#A1, #A1, #C, #C> // arrow.optics.typeclasses/Index.index|index@arrow.optics.PTraversal<0:0,0:0,1:0,1:0>(1:1){0§<kotlin.Any?>}[0]
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics.typeclasses/Cons { // arrow.optics.typeclasses/Cons|null[0]
    abstract fun cons(): arrow.optics/PPrism<#A, #A, kotlin/Pair<#B, #A>, kotlin/Pair<#B, #A>> // arrow.optics.typeclasses/Cons.cons|cons(){}[0]
    final object Companion { // arrow.optics.typeclasses/Cons.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> invoke(arrow.optics/PPrism<#A2, #A2, kotlin/Pair<#B2, #A2>, kotlin/Pair<#B2, #A2>>): arrow.optics.typeclasses/Cons<#A2, #B2> // arrow.optics.typeclasses/Cons.Companion.invoke|invoke(arrow.optics.PPrism<0:0,0:0,kotlin.Pair<0:1,0:0>,kotlin.Pair<0:1,0:0>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/Cons<kotlin.collections/List<#A2>, #A2> // arrow.optics.typeclasses/Cons.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/Cons<kotlin/String, kotlin/Char> // arrow.optics.typeclasses/Cons.Companion.string|string(){}[0]
    }
    open fun (#A).uncons(): kotlin/Pair<#B, #A>? // arrow.optics.typeclasses/Cons.uncons|uncons@1:0(){}[0]
    open fun (#B).cons(#A): #A // arrow.optics.typeclasses/Cons.cons|cons@1:1(1:0){}[0]
    open fun firstOption(): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.typeclasses/Cons.firstOption|firstOption(){}[0]
    open fun tailOption(): arrow.optics/POptional<#A, #A, #A, #A> // arrow.optics.typeclasses/Cons.tailOption|tailOption(){}[0]
}
abstract fun interface <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics.typeclasses/Snoc { // arrow.optics.typeclasses/Snoc|null[0]
    abstract fun snoc(): arrow.optics/PPrism<#A, #A, kotlin/Pair<#A, #B>, kotlin/Pair<#A, #B>> // arrow.optics.typeclasses/Snoc.snoc|snoc(){}[0]
    final object Companion { // arrow.optics.typeclasses/Snoc.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> invoke(arrow.optics/PPrism<#A2, #A2, kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #B2>>): arrow.optics.typeclasses/Snoc<#A2, #B2> // arrow.optics.typeclasses/Snoc.Companion.invoke|invoke(arrow.optics.PPrism<0:0,0:0,kotlin.Pair<0:0,0:1>,kotlin.Pair<0:0,0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics.typeclasses/Snoc<kotlin.collections/List<#A2>, #A2> // arrow.optics.typeclasses/Snoc.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics.typeclasses/Snoc<kotlin/String, kotlin/Char> // arrow.optics.typeclasses/Snoc.Companion.string|string(){}[0]
    }
    open fun (#A).snoc(#B): #A // arrow.optics.typeclasses/Snoc.snoc|snoc@1:0(1:1){}[0]
    open fun (#A).unsnoc(): kotlin/Pair<#A, #B>? // arrow.optics.typeclasses/Snoc.unsnoc|unsnoc@1:0(){}[0]
    open fun initOption(): arrow.optics/POptional<#A, #A, #A, #A> // arrow.optics.typeclasses/Snoc.initOption|initOption(){}[0]
    open fun lastOption(): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.typeclasses/Snoc.lastOption|lastOption(){}[0]
    open val init // arrow.optics.typeclasses/Snoc.init|@1:0{}init[0]
        open fun (#A).<get-init>(): #A? // arrow.optics.typeclasses/Snoc.init.<get-init>|<get-init>@1:0(){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PIso : arrow.optics/PLens<#A, #B, #C, #D>, arrow.optics/PPrism<#A, #B, #C, #D> { // arrow.optics/PIso|null[0]
    abstract fun get(#A): #C // arrow.optics/PIso.get|get(1:0){}[0]
    abstract fun reverseGet(#D): #B // arrow.optics/PIso.reverseGet|reverseGet(1:3){}[0]
    final object Companion { // arrow.optics/PIso.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#D2, #B2>): arrow.optics/PIso<#A2, #B2, #C2, #D2> // arrow.optics/PIso.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> listToPOptionNel(): arrow.optics/PIso<kotlin.collections/List<#A2>, kotlin.collections/List<#B2>, arrow.core/Option<arrow.core/NonEmptyList<#A2>>, arrow.core/Option<arrow.core/NonEmptyList<#B2>>> // arrow.optics/PIso.Companion.listToPOptionNel|listToPOptionNel(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> nullableToOption(): arrow.optics/PIso<#A2?, #B2?, arrow.core/Option<#A2>, arrow.core/Option<#B2>> // arrow.optics/PIso.Companion.nullableToOption|nullableToOption(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> nullableToPOption(): arrow.optics/PIso<#A2?, #B2?, arrow.core/Option<#A2>, arrow.core/Option<#B2>> // arrow.optics/PIso.Companion.nullableToPOption|nullableToPOption(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> optionToPEither(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#B2>, arrow.core/Either<kotlin/Unit, #A2>, arrow.core/Either<kotlin/Unit, #B2>> // arrow.optics/PIso.Companion.optionToPEither|optionToPEither(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> optionToPNullable(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#B2>, #A2?, #B2?> // arrow.optics/PIso.Companion.optionToPNullable|optionToPNullable(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PIso.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> listToOptionNel(): arrow.optics/PIso<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, arrow.core/Option<arrow.core/NonEmptyList<#A2>>, arrow.core/Option<arrow.core/NonEmptyList<#A2>>> // arrow.optics/PIso.Companion.listToOptionNel|listToOptionNel(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> mapToSet(): arrow.optics/PIso<kotlin.collections/Map<#A2, kotlin/Unit>, kotlin.collections/Map<#A2, kotlin/Unit>, kotlin.collections/Set<#A2>, kotlin.collections/Set<#A2>> // arrow.optics/PIso.Companion.mapToSet|mapToSet(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> optionToEither(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#A2>, arrow.core/Either<kotlin/Unit, #A2>, arrow.core/Either<kotlin/Unit, #A2>> // arrow.optics/PIso.Companion.optionToEither|optionToEither(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> optionToNullable(): arrow.optics/PIso<arrow.core/Option<#A2>, arrow.core/Option<#A2>, #A2?, #A2?> // arrow.optics/PIso.Companion.optionToNullable|optionToNullable(){0§<kotlin.Any?>}[0]
        final fun stringToList(): arrow.optics/PIso<kotlin/String, kotlin/String, kotlin.collections/List<kotlin/Char>, kotlin.collections/List<kotlin/Char>> // arrow.optics/PIso.Companion.stringToList|stringToList(){}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?, #D1: kotlin/Any?> split(arrow.optics/PIso<#A1, #B1, #C1, #D1>): arrow.optics/PIso<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #B1>, kotlin/Pair<#C, #C1>, kotlin/Pair<#D, #D1>> // arrow.optics/PIso.split|split(arrow.optics.PIso<0:0,0:1,0:2,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PIso<in #C, out #D, out #A1, in #B1>): arrow.optics/PIso<#A, #B, #A1, #B1> // arrow.optics/PIso.compose|compose(arrow.optics.PIso<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PIso<in #C, out #D, out #A1, in #B1>): arrow.optics/PIso<#A, #B, #A1, #B1> // arrow.optics/PIso.plus|plus(arrow.optics.PIso<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/PIso<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/PIso.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PIso.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> left(): arrow.optics/PIso<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #A1>, arrow.core/Either<#C, #A1>, arrow.core/Either<#D, #A1>> // arrow.optics/PIso.left|left(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> right(): arrow.optics/PIso<arrow.core/Either<#A1, #A>, arrow.core/Either<#A1, #B>, arrow.core/Either<#A1, #C>, arrow.core/Either<#A1, #D>> // arrow.optics/PIso.right|right(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/PIso<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/PIso.second|second(){0§<kotlin.Any?>}[0]
    open fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/PIso.getOrModify|getOrModify(1:0){}[0]
    open fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/PIso.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun reverse(): arrow.optics/PIso<#D, #C, #B, #A> // arrow.optics/PIso.reverse|reverse(){}[0]
    open fun set(#A, #D): #B // arrow.optics/PIso.set|set(1:0;1:3){}[0]
    open fun set(#D): #B // arrow.optics/PIso.set|set(1:3){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PLens : arrow.optics/POptional<#A, #B, #C, #D> { // arrow.optics/PLens|null[0]
    abstract fun get(#A): #C // arrow.optics/PLens.get|get(1:0){}[0]
    abstract fun set(#A, #D): #B // arrow.optics/PLens.set|set(1:0;1:3){}[0]
    final object Companion { // arrow.optics/PLens.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function2<#A2, #D2, #B2>): arrow.optics/PLens<#A2, #B2, #C2, #D2> // arrow.optics/PLens.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function2<0:0,0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> triplePFirst(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#D2, #B2, #C2>, #A2, #D2> // arrow.optics/PLens.Companion.triplePFirst|triplePFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> triplePSecond(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #D2, #C2>, #B2, #D2> // arrow.optics/PLens.Companion.triplePSecond|triplePSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> triplePThird(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #D2>, #C2, #D2> // arrow.optics/PLens.Companion.triplePThird|triplePThird(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pairPFirst(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#C2, #B2>, #A2, #C2> // arrow.optics/PLens.Companion.pairPFirst|pairPFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pairPSecond(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #C2>, #B2, #C2> // arrow.optics/PLens.Companion.pairPSecond|pairPSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> tripleFirst(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #C2>, #A2, #A2> // arrow.optics/PLens.Companion.tripleFirst|tripleFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> tripleSecond(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #C2>, #B2, #B2> // arrow.optics/PLens.Companion.tripleSecond|tripleSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> tripleThird(): arrow.optics/PLens<kotlin/Triple<#A2, #B2, #C2>, kotlin/Triple<#A2, #B2, #C2>, #C2, #C2> // arrow.optics/PLens.Companion.tripleThird|tripleThird(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pairFirst(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #B2>, #A2, #A2> // arrow.optics/PLens.Companion.pairFirst|pairFirst(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pairSecond(): arrow.optics/PLens<kotlin/Pair<#A2, #B2>, kotlin/Pair<#A2, #B2>, #B2, #B2> // arrow.optics/PLens.Companion.pairSecond|pairSecond(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> codiagonal(): arrow.optics/PLens<arrow.core/Either<#A2, #A2>, arrow.core/Either<#A2, #A2>, #A2, #A2> // arrow.optics/PLens.Companion.codiagonal|codiagonal(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PLens.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyListHead(): arrow.optics/PLens<arrow.core/NonEmptyList<#A2>, arrow.core/NonEmptyList<#A2>, #A2, #A2> // arrow.optics/PLens.Companion.nonEmptyListHead|nonEmptyListHead(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyListTail(): arrow.optics/PLens<arrow.core/NonEmptyList<#A2>, arrow.core/NonEmptyList<#A2>, kotlin.collections/List<#A2>, kotlin.collections/List<#A2>> // arrow.optics/PLens.Companion.nonEmptyListTail|nonEmptyListTail(){0§<kotlin.Any?>}[0]
        final fun stringToList(): arrow.optics/PLens<kotlin/String, kotlin/String, kotlin.collections/List<kotlin/Char>, kotlin.collections/List<kotlin/Char>> // arrow.optics/PLens.Companion.stringToList|stringToList(){}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?, #D1: kotlin/Any?> split(arrow.optics/PLens<#A1, #B1, #C1, #D1>): arrow.optics/PLens<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #B1>, kotlin/Pair<#C, #C1>, kotlin/Pair<#D, #D1>> // arrow.optics/PLens.split|split(arrow.optics.PLens<0:0,0:1,0:2,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> choice(arrow.optics/PLens<#A1, #B1, #C, #D>): arrow.optics/PLens<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #B1>, #C, #D> // arrow.optics/PLens.choice|choice(arrow.optics.PLens<0:0,0:1,1:2,1:3>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PLens<in #C, out #D, out #A1, in #B1>): arrow.optics/PLens<#A, #B, #A1, #B1> // arrow.optics/PLens.compose|compose(arrow.optics.PLens<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PLens<in #C, out #D, out #A1, in #B1>): arrow.optics/PLens<#A, #B, #A1, #B1> // arrow.optics/PLens.plus|plus(arrow.optics.PLens<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/PLens<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/PLens.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PLens.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/PLens<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/PLens.second|second(){0§<kotlin.Any?>}[0]
    open fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/PLens.getOrModify|getOrModify(1:0){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/POptional : arrow.optics/PTraversal<#A, #B, #C, #D> { // arrow.optics/POptional|null[0]
    abstract fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/POptional.getOrModify|getOrModify(1:0){}[0]
    abstract fun set(#A, #D): #B // arrow.optics/POptional.set|set(1:0;1:3){}[0]
    final object Companion { // arrow.optics/POptional.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, arrow.core/Either<#B2, #C2>>, kotlin/Function2<#A2, #D2, #B2>): arrow.optics/POptional<#A2, #B2, #C2, #D2> // arrow.optics/POptional.Companion.invoke|invoke(kotlin.Function1<0:0,arrow.core.Either<0:1,0:2>>;kotlin.Function2<0:0,0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> void(): arrow.optics/POptional<#A2, #A2, #B2, #B2> // arrow.optics/POptional.Companion.void|void(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> codiagonal(): arrow.optics/POptional<arrow.core/Either<#A2, #A2>, arrow.core/Either<#A2, #A2>, #A2, #A2> // arrow.optics/POptional.Companion.codiagonal|codiagonal(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/POptional.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> listHead(): arrow.optics/POptional<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, #A2, #A2> // arrow.optics/POptional.Companion.listHead|listHead(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> listTail(): arrow.optics/POptional<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, kotlin.collections/List<#A2>> // arrow.optics/POptional.Companion.listTail|listTail(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> notNull(): arrow.optics/POptional<#A2?, #A2?, #A2, #A2> // arrow.optics/POptional.Companion.notNull|notNull(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nullable(): arrow.optics/POptional<#A2?, #A2?, #A2, #A2> // arrow.optics/POptional.Companion.nullable|nullable(){0§<kotlin.Any?>}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> choice(arrow.optics/POptional<#A1, #B1, #C, #D>): arrow.optics/POptional<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #B1>, #C, #D> // arrow.optics/POptional.choice|choice(arrow.optics.POptional<0:0,0:1,1:2,1:3>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/POptional<in #C, out #D, out #A1, in #B1>): arrow.optics/POptional<#A, #B, #A1, #B1> // arrow.optics/POptional.compose|compose(arrow.optics.POptional<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/POptional<in #C, out #D, out #A1, in #B1>): arrow.optics/POptional<#A, #B, #A1, #B1> // arrow.optics/POptional.plus|plus(arrow.optics.POptional<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/POptional<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/POptional.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/POptional.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/POptional<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/POptional.second|second(){0§<kotlin.Any?>}[0]
    open fun getOrNull(#A): #C? // arrow.optics/POptional.getOrNull|getOrNull(1:0){}[0]
    open fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/POptional.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun modifyNullable(#A, kotlin/Function1<#C, #D>): #B? // arrow.optics/POptional.modifyNullable|modifyNullable(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun setNullable(#A, #D): #B? // arrow.optics/POptional.setNullable|setNullable(1:0;1:3){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PPrism : arrow.optics/POptional<#A, #B, #C, #D> { // arrow.optics/PPrism|null[0]
    abstract fun getOrModify(#A): arrow.core/Either<#B, #C> // arrow.optics/PPrism.getOrModify|getOrModify(1:0){}[0]
    abstract fun reverseGet(#D): #B // arrow.optics/PPrism.reverseGet|reverseGet(1:3){}[0]
    final object Companion { // arrow.optics/PPrism.Companion|null[0]
        final fun <#A2: kotlin/Any, #B2: #A2> instanceOf(kotlin.reflect/KClass<#B2>): arrow.optics/PPrism<#A2, #A2, #B2, #B2> // arrow.optics/PPrism.Companion.instanceOf|instanceOf(kotlin.reflect.KClass<0:1>){0§<kotlin.Any>;1§<0:0>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, arrow.core/Either<#B2, #C2>>, kotlin/Function1<#D2, #B2>): arrow.optics/PPrism<#A2, #B2, #C2, #D2> // arrow.optics/PPrism.Companion.invoke|invoke(kotlin.Function1<0:0,arrow.core.Either<0:1,0:2>>;kotlin.Function1<0:3,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pLeft(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#C2, #B2>, #A2, #C2> // arrow.optics/PPrism.Companion.pLeft|pLeft(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?> pRight(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #C2>, #B2, #C2> // arrow.optics/PPrism.Companion.pRight|pRight(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> left(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #B2>, #A2, #A2> // arrow.optics/PPrism.Companion.left|left(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pSome(): arrow.optics/PPrism<arrow.core/Option<#A2>, arrow.core/Option<#B2>, #A2, #B2> // arrow.optics/PPrism.Companion.pSome|pSome(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> right(): arrow.optics/PPrism<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #B2>, #B2, #B2> // arrow.optics/PPrism.Companion.right|right(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PPrism.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> none(): arrow.optics/PPrism<arrow.core/Option<#A2>, arrow.core/Option<#A2>, kotlin/Unit, kotlin/Unit> // arrow.optics/PPrism.Companion.none|none(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> only(#A2, kotlin/Function2<#A2, #A2, kotlin/Boolean> = ...): arrow.optics/PPrism<#A2, #A2, kotlin/Unit, kotlin/Unit> // arrow.optics/PPrism.Companion.only|only(0:0;kotlin.Function2<0:0,0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> some(): arrow.optics/PPrism<arrow.core/Option<#A2>, arrow.core/Option<#A2>, #A2, #A2> // arrow.optics/PPrism.Companion.some|some(){0§<kotlin.Any?>}[0]
        final inline fun <#A2: kotlin/Any?, #B2: reified #A2> instanceOf(): arrow.optics/PPrism<#A2, #A2, #B2, #B2> // arrow.optics/PPrism.Companion.instanceOf|instanceOf(){0§<kotlin.Any?>;1§<0:0>}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PPrism<in #C, out #D, out #A1, in #B1>): arrow.optics/PPrism<#A, #B, #A1, #B1> // arrow.optics/PPrism.compose|compose(arrow.optics.PPrism<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PPrism<in #C, out #D, out #A1, in #B1>): arrow.optics/PPrism<#A, #B, #A1, #B1> // arrow.optics/PPrism.plus|plus(arrow.optics.PPrism<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> first(): arrow.optics/PPrism<kotlin/Pair<#A, #A1>, kotlin/Pair<#B, #A1>, kotlin/Pair<#C, #A1>, kotlin/Pair<#D, #A1>> // arrow.optics/PPrism.first|first(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PPrism.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> left(): arrow.optics/PPrism<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #A1>, arrow.core/Either<#C, #A1>, arrow.core/Either<#D, #A1>> // arrow.optics/PPrism.left|left(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> right(): arrow.optics/PPrism<arrow.core/Either<#A1, #A>, arrow.core/Either<#A1, #B>, arrow.core/Either<#A1, #C>, arrow.core/Either<#A1, #D>> // arrow.optics/PPrism.right|right(){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> second(): arrow.optics/PPrism<kotlin/Pair<#A1, #A>, kotlin/Pair<#A1, #B>, kotlin/Pair<#A1, #C>, kotlin/Pair<#A1, #D>> // arrow.optics/PPrism.second|second(){0§<kotlin.Any?>}[0]
    open fun liftNullable(kotlin/Function1<#C, #D>): kotlin/Function1<#A, #B?> // arrow.optics/PPrism.liftNullable|liftNullable(kotlin.Function1<1:2,1:3>){}[0]
    open fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/PPrism.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    open fun set(#A, #D): #B // arrow.optics/PPrism.set|set(1:0;1:3){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics/PTraversal { // arrow.optics/PTraversal|null[0]
    abstract fun <#A1: kotlin/Any?> foldMap(#A1, kotlin/Function2<#A1, #A1, #A1>, #A, kotlin/Function1<#C, #A1>): #A1 // arrow.optics/PTraversal.foldMap|foldMap(0:0;kotlin.Function2<0:0,0:0,0:0>;1:0;kotlin.Function1<1:2,0:0>){0§<kotlin.Any?>}[0]
    abstract fun modify(#A, kotlin/Function1<#C, #D>): #B // arrow.optics/PTraversal.modify|modify(1:0;kotlin.Function1<1:2,1:3>){}[0]
    final object Companion { // arrow.optics/PTraversal.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function10<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function10<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function11<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function11<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function9<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function9<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function8<#D2, #D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function8<0:3,0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function7<#D2, #D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function7<0:3,0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function6<#D2, #D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function6<0:3,0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function5<#D2, #D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function5<0:3,0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function4<#D2, #D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function4<0:3,0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?, #C2: kotlin/Any?, #D2: kotlin/Any?> invoke(kotlin/Function1<#A2, #C2>, kotlin/Function1<#A2, #C2>, kotlin/Function3<#D2, #D2, #A2, #B2>): arrow.optics/PTraversal<#A2, #B2, #C2, #D2> // arrow.optics/PTraversal.Companion.invoke|invoke(kotlin.Function1<0:0,0:2>;kotlin.Function1<0:0,0:2>;kotlin.Function3<0:3,0:3,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> either(): arrow.optics/PTraversal<arrow.core/Either<#A2, #B2>, arrow.core/Either<#A2, #B2>, #B2, #B2> // arrow.optics/PTraversal.Companion.either|either(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> map(): arrow.optics/PTraversal<kotlin.collections/Map<#A2, #B2>, kotlin.collections/Map<#A2, #B2>, #B2, #B2> // arrow.optics/PTraversal.Companion.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pPair(): arrow.optics/PTraversal<kotlin/Pair<#A2, #A2>, kotlin/Pair<#B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pPair|pPair(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTriple(): arrow.optics/PTraversal<kotlin/Triple<#A2, #A2, #A2>, kotlin/Triple<#B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTriple|pTriple(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple4(): arrow.optics/PTraversal<arrow.core/Tuple4<#A2, #A2, #A2, #A2>, arrow.core/Tuple4<#B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple4|pTuple4(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple5(): arrow.optics/PTraversal<arrow.core/Tuple5<#A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple5<#B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple5|pTuple5(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple6(): arrow.optics/PTraversal<arrow.core/Tuple6<#A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple6<#B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple6|pTuple6(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple7(): arrow.optics/PTraversal<arrow.core/Tuple7<#A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple7<#B2, #B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple7|pTuple7(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple8(): arrow.optics/PTraversal<arrow.core/Tuple8<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple8<#B2, #B2, #B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple8|pTuple8(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> pTuple9(): arrow.optics/PTraversal<arrow.core/Tuple9<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple9<#B2, #B2, #B2, #B2, #B2, #B2, #B2, #B2, #B2>, #A2, #B2> // arrow.optics/PTraversal.Companion.pTuple9|pTuple9(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> void(): arrow.optics/PTraversal<#A2, #A2, #B2, #B2> // arrow.optics/PTraversal.Companion.void|void(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> codiagonal(): arrow.optics/PTraversal<arrow.core/Either<#A2, #A2>, arrow.core/Either<#A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.codiagonal|codiagonal(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> id(): arrow.optics/PIso<#A2, #A2, #A2, #A2> // arrow.optics/PTraversal.Companion.id|id(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> list(): arrow.optics/PTraversal<kotlin.collections/List<#A2>, kotlin.collections/List<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.list|list(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> nonEmptyList(): arrow.optics/PTraversal<arrow.core/NonEmptyList<#A2>, arrow.core/NonEmptyList<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> option(): arrow.optics/PTraversal<arrow.core/Option<#A2>, arrow.core/Option<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.option|option(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> pair(): arrow.optics/PTraversal<kotlin/Pair<#A2, #A2>, kotlin/Pair<#A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.pair|pair(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> sequence(): arrow.optics/PTraversal<kotlin.sequences/Sequence<#A2>, kotlin.sequences/Sequence<#A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.sequence|sequence(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> triple(): arrow.optics/PTraversal<kotlin/Triple<#A2, #A2, #A2>, kotlin/Triple<#A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.triple|triple(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple4(): arrow.optics/PTraversal<arrow.core/Tuple4<#A2, #A2, #A2, #A2>, arrow.core/Tuple4<#A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple4|tuple4(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple5(): arrow.optics/PTraversal<arrow.core/Tuple5<#A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple5<#A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple5|tuple5(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple6(): arrow.optics/PTraversal<arrow.core/Tuple6<#A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple6<#A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple6|tuple6(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple7(): arrow.optics/PTraversal<arrow.core/Tuple7<#A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple7<#A2, #A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple7|tuple7(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple8(): arrow.optics/PTraversal<arrow.core/Tuple8<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple8<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple8|tuple8(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tuple9(): arrow.optics/PTraversal<arrow.core/Tuple9<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, arrow.core/Tuple9<#A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2, #A2>, #A2, #A2> // arrow.optics/PTraversal.Companion.tuple9|tuple9(){0§<kotlin.Any?>}[0]
        final fun string(): arrow.optics/PTraversal<kotlin/String, kotlin/String, kotlin/Char, kotlin/Char> // arrow.optics/PTraversal.Companion.string|string(){}[0]
    }
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> choice(arrow.optics/PTraversal<#A1, #B1, #C, #D>): arrow.optics/PTraversal<arrow.core/Either<#A, #A1>, arrow.core/Either<#B, #B1>, #C, #D> // arrow.optics/PTraversal.choice|choice(arrow.optics.PTraversal<0:0,0:1,1:2,1:3>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> compose(arrow.optics/PTraversal<in #C, out #D, out #A1, in #B1>): arrow.optics/PTraversal<#A, #B, #A1, #B1> // arrow.optics/PTraversal.compose|compose(arrow.optics.PTraversal<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> plus(arrow.optics/PTraversal<in #C, out #D, out #A1, in #B1>): arrow.optics/PTraversal<#A, #B, #A1, #B1> // arrow.optics/PTraversal.plus|plus(arrow.optics.PTraversal<in|1:2,out|1:3,out|0:0,in|0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun all(#A, kotlin/Function1<#C, kotlin/Boolean>): kotlin/Boolean // arrow.optics/PTraversal.all|all(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun any(#A, kotlin/Function1<#C, kotlin/Boolean>): kotlin/Boolean // arrow.optics/PTraversal.any|any(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun exists(#A, kotlin/Function1<#C, kotlin/Boolean>): kotlin/Boolean // arrow.optics/PTraversal.exists|exists(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun findOrNull(#A, kotlin/Function1<#C, kotlin/Boolean>): #C? // arrow.optics/PTraversal.findOrNull|findOrNull(1:0;kotlin.Function1<1:2,kotlin.Boolean>){}[0]
    open fun firstOrNull(#A): #C? // arrow.optics/PTraversal.firstOrNull|firstOrNull(1:0){}[0]
    open fun fold(#C, kotlin/Function2<#C, #C, #C>, #A): #C // arrow.optics/PTraversal.fold|fold(1:2;kotlin.Function2<1:2,1:2,1:2>;1:0){}[0]
    open fun getAll(#A): kotlin.collections/List<#C> // arrow.optics/PTraversal.getAll|getAll(1:0){}[0]
    open fun isEmpty(#A): kotlin/Boolean // arrow.optics/PTraversal.isEmpty|isEmpty(1:0){}[0]
    open fun isNotEmpty(#A): kotlin/Boolean // arrow.optics/PTraversal.isNotEmpty|isNotEmpty(1:0){}[0]
    open fun lastOrNull(#A): #C? // arrow.optics/PTraversal.lastOrNull|lastOrNull(1:0){}[0]
    open fun lift(kotlin/Function1<#C, #D>): kotlin/Function1<#A, #B> // arrow.optics/PTraversal.lift|lift(kotlin.Function1<1:2,1:3>){}[0]
    open fun set(#A, #D): #B // arrow.optics/PTraversal.set|set(1:0;1:3){}[0]
    open fun size(#A): kotlin/Int // arrow.optics/PTraversal.size|size(1:0){}[0]
}
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics.match/MatchScope { // arrow.optics.match/MatchScope|null[0]
    abstract fun <#A1: kotlin/Any?> (arrow.optics/POptional<#A, #A, #A1, #A1>).then(kotlin/Function1<#A1, #B>) // arrow.optics.match/MatchScope.then|then@arrow.optics.POptional<1:0,1:0,0:0,0:0>(kotlin.Function1<0:0,1:1>){0§<kotlin.Any?>}[0]
    abstract fun default(kotlin/Function0<#B>) // arrow.optics.match/MatchScope.default|default(kotlin.Function0<1:1>){}[0]
}
abstract interface <#A: kotlin/Any?> arrow.optics/Copy { // arrow.optics/Copy|null[0]
    abstract fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #A1, #A1>).set(#A1) // arrow.optics/Copy.set|set@arrow.optics.PTraversal<1:0,1:0,0:0,0:0>(0:0){0§<kotlin.Any?>}[0]
    abstract fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #A1, #A1>).transform(kotlin/Function1<#A1, #A1>) // arrow.optics/Copy.transform|transform@arrow.optics.PTraversal<1:0,1:0,0:0,0:0>(kotlin.Function1<0:0,0:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> inside(arrow.optics/PTraversal<#A, #A, #A1, #A1>, kotlin/Function1<arrow.optics/Copy<#A1>, kotlin/Unit>) // arrow.optics/Copy.inside|inside(arrow.optics.PTraversal<1:0,1:0,0:0,0:0>;kotlin.Function1<arrow.optics.Copy<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
}
final class arrow.optics.match/MatchNotFound : kotlin/Throwable { // arrow.optics.match/MatchNotFound|null[0]
    constructor <init>(kotlin/Any?) // arrow.optics.match/MatchNotFound.<init>|<init>(kotlin.Any?){}[0]
    final val value // arrow.optics.match/MatchNotFound.value|{}value[0]
        final fun <get-value>(): kotlin/Any? // arrow.optics.match/MatchNotFound.value.<get-value>|<get-value>(){}[0]
}
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?, #F: kotlin/Any?, #G: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/invoke(arrow.optics/POptional<#B, #B, #C, #C>, arrow.optics/POptional<#B, #B, #D, #D>, arrow.optics/POptional<#B, #B, #E, #E>, arrow.optics/POptional<#B, #B, #F, #F>, arrow.optics/POptional<#B, #B, #G, #G>): arrow.optics/POptional<#A, #A, arrow.core/Tuple5<#C, #D, #E, #F, #G>, arrow.core/Tuple5<#C, #D, #E, #F, #G>> // arrow.optics.match/invoke|invoke@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.POptional<0:1,0:1,0:2,0:2>;arrow.optics.POptional<0:1,0:1,0:3,0:3>;arrow.optics.POptional<0:1,0:1,0:4,0:4>;arrow.optics.POptional<0:1,0:1,0:5,0:5>;arrow.optics.POptional<0:1,0:1,0:6,0:6>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>;6§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?, #F: kotlin/Any?> (arrow.optics/PLens<#A, #B, #C?, #D?>).arrow.optics/composeNull(arrow.optics/PLens<#C, #D, #E, #F>): arrow.optics/PLens<#A, #B, #E?, #F?> // arrow.optics/composeNull|composeNull@arrow.optics.PLens<0:0,0:1,0:2?,0:3?>(arrow.optics.PLens<0:2,0:3,0:4,0:5>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?, #F: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/invoke(arrow.optics/POptional<#B, #B, #C, #C>, arrow.optics/POptional<#B, #B, #D, #D>, arrow.optics/POptional<#B, #B, #E, #E>, arrow.optics/POptional<#B, #B, #F, #F>): arrow.optics/POptional<#A, #A, arrow.core/Tuple4<#C, #D, #E, #F>, arrow.core/Tuple4<#C, #D, #E, #F>> // arrow.optics.match/invoke|invoke@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.POptional<0:1,0:1,0:2,0:2>;arrow.optics.POptional<0:1,0:1,0:3,0:3>;arrow.optics.POptional<0:1,0:1,0:4,0:4>;arrow.optics.POptional<0:1,0:1,0:5,0:5>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?, #F: kotlin/Any?> arrow.optics.match/it(arrow.optics/POptional<#A, #A, #B, #B>, arrow.optics/POptional<#A, #A, #C, #C>, arrow.optics/POptional<#A, #A, #D, #D>, arrow.optics/POptional<#A, #A, #E, #E>, arrow.optics/POptional<#A, #A, #F, #F>): arrow.optics/POptional<#A, #A, arrow.core/Tuple5<#B, #C, #D, #E, #F>, arrow.core/Tuple5<#B, #C, #D, #E, #F>> // arrow.optics.match/it|it(arrow.optics.POptional<0:0,0:0,0:1,0:1>;arrow.optics.POptional<0:0,0:0,0:2,0:2>;arrow.optics.POptional<0:0,0:0,0:3,0:3>;arrow.optics.POptional<0:0,0:0,0:4,0:4>;arrow.optics.POptional<0:0,0:0,0:5,0:5>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/invoke(arrow.optics/POptional<#B, #B, #C, #C>, arrow.optics/POptional<#B, #B, #D, #D>, arrow.optics/POptional<#B, #B, #E, #E>): arrow.optics/POptional<#A, #A, kotlin/Triple<#C, #D, #E>, kotlin/Triple<#C, #D, #E>> // arrow.optics.match/invoke|invoke@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.POptional<0:1,0:1,0:2,0:2>;arrow.optics.POptional<0:1,0:1,0:3,0:3>;arrow.optics.POptional<0:1,0:1,0:4,0:4>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?> arrow.optics.match/it(arrow.optics/POptional<#A, #A, #B, #B>, arrow.optics/POptional<#A, #A, #C, #C>, arrow.optics/POptional<#A, #A, #D, #D>, arrow.optics/POptional<#A, #A, #E, #E>): arrow.optics/POptional<#A, #A, arrow.core/Tuple4<#B, #C, #D, #E>, arrow.core/Tuple4<#B, #C, #D, #E>> // arrow.optics.match/it|it(arrow.optics.POptional<0:0,0:0,0:1,0:1>;arrow.optics.POptional<0:0,0:0,0:2,0:2>;arrow.optics.POptional<0:0,0:0,0:3,0:3>;arrow.optics.POptional<0:0,0:0,0:4,0:4>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/PLens<#A, #A, #B, #B>).arrow.optics.dsl/at(arrow.optics.typeclasses/At<#B, #C, #D>, #C): arrow.optics/PLens<#A, #A, #D, #D> // arrow.optics.dsl/at|at@arrow.optics.PLens<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.At<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.dsl/at(arrow.optics.typeclasses/At<#B, #C, #D>, #C): arrow.optics/POptional<#A, #A, #D, #D> // arrow.optics.dsl/at|at@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.At<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.dsl/index(arrow.optics.typeclasses/Index<#B, #C, #D>, #C): arrow.optics/POptional<#A, #A, #D, #D> // arrow.optics.dsl/index|index@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.Index<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/invoke(arrow.optics/POptional<#B, #B, #C, #C>, arrow.optics/POptional<#B, #B, #D, #D>): arrow.optics/POptional<#A, #A, kotlin/Pair<#C, #D>, kotlin/Pair<#C, #D>> // arrow.optics.match/invoke|invoke@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.POptional<0:1,0:1,0:2,0:2>;arrow.optics.POptional<0:1,0:1,0:3,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #B, #B>).arrow.optics.dsl/at(arrow.optics.typeclasses/At<#B, #C, #D>, #C): arrow.optics/PTraversal<#A, #A, #D, #D> // arrow.optics.dsl/at|at@arrow.optics.PTraversal<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.At<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #B, #B>).arrow.optics.dsl/filter(arrow.optics.typeclasses/FilterIndex<#B, #C, #D>, kotlin/Function1<#C, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, #D, #D> // arrow.optics.dsl/filter|filter@arrow.optics.PTraversal<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.FilterIndex<0:1,0:2,0:3>;kotlin.Function1<0:2,kotlin.Boolean>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #B, #B>).arrow.optics.dsl/index(arrow.optics.typeclasses/Index<#B, #C, #D>, #C): arrow.optics/PTraversal<#A, #A, #D, #D> // arrow.optics.dsl/index|index@arrow.optics.PTraversal<0:0,0:0,0:1,0:1>(arrow.optics.typeclasses.Index<0:1,0:2,0:3>;0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> arrow.optics.match/it(arrow.optics/POptional<#A, #A, #B, #B>, arrow.optics/POptional<#A, #A, #C, #C>, arrow.optics/POptional<#A, #A, #D, #D>): arrow.optics/POptional<#A, #A, kotlin/Triple<#B, #C, #D>, kotlin/Triple<#B, #C, #D>> // arrow.optics.match/it|it(arrow.optics.POptional<0:0,0:0,0:1,0:1>;arrow.optics.POptional<0:0,0:0,0:2,0:2>;arrow.optics.POptional<0:0,0:0,0:3,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.core.raise/SingletonRaise<#C>).arrow.optics.match/matchOrRaise(#A, kotlin/Function1<arrow.optics.match/MatchScope<#A, #B>, kotlin/Unit>): #B // arrow.optics.match/matchOrRaise|matchOrRaise@arrow.core.raise.SingletonRaise<0:2>(0:0;kotlin.Function1<arrow.optics.match.MatchScope<0:0,0:1>,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics.typeclasses/At<#A, #B, arrow.core/Option<#C>>).arrow.optics.typeclasses/remove(#A, #B): #A // arrow.optics.typeclasses/remove|remove@arrow.optics.typeclasses.At<0:0,0:1,arrow.core.Option<0:2>>(0:0;0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics.typeclasses/At<#A, #B, arrow.core/Option<#C>>).arrow.optics.typeclasses/remove(#B): kotlin/Function1<#A, #A> // arrow.optics.typeclasses/remove|remove@arrow.optics.typeclasses.At<0:0,0:1,arrow.core.Option<0:2>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/PLens<#A, #A, kotlin.collections/Map<#B, #C>, kotlin.collections/Map<#B, #C>>).arrow.optics.dsl/at(#B): arrow.optics/PLens<#A, #A, arrow.core/Option<#C>, arrow.core/Option<#C>> // arrow.optics.dsl/at|at@arrow.optics.PLens<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/invoke(arrow.optics/POptional<#B, #B, #C, #C>): arrow.optics/POptional<#A, #A, #C, #C> // arrow.optics.match/invoke|invoke@arrow.optics.POptional<0:0,0:0,0:1,0:1>(arrow.optics.POptional<0:1,0:1,0:2,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/POptional<#A, #A, kotlin.collections/Map<#B, #C>, kotlin.collections/Map<#B, #C>>).arrow.optics.dsl/at(#B): arrow.optics/POptional<#A, #A, arrow.core/Option<#C>, arrow.core/Option<#C>> // arrow.optics.dsl/at|at@arrow.optics.POptional<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/POptional<#A, #A, kotlin.collections/Map<#B, #C>, kotlin.collections/Map<#B, #C>>).arrow.optics.dsl/index(#B): arrow.optics/POptional<#A, #A, #C, #C> // arrow.optics.dsl/index|index@arrow.optics.POptional<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, #B, #B>).arrow.optics.dsl/every(arrow.optics/PTraversal<#B, #B, #C, #C>): arrow.optics/PTraversal<#A, #A, #C, #C> // arrow.optics.dsl/every|every@arrow.optics.PTraversal<0:0,0:0,0:1,0:1>(arrow.optics.PTraversal<0:1,0:1,0:2,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.collections/Map<#B, #C>, kotlin.collections/Map<#B, #C>>).arrow.optics.dsl/at(#B): arrow.optics/PTraversal<#A, #A, arrow.core/Option<#C>, arrow.core/Option<#C>> // arrow.optics.dsl/at|at@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.collections/Map<#B, #C>, kotlin.collections/Map<#B, #C>>).arrow.optics.dsl/filter(kotlin/Function1<#B, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, #C, #C> // arrow.optics.dsl/filter|filter@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>(kotlin.Function1<0:1,kotlin.Boolean>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.collections/Map<#B, #C>, kotlin.collections/Map<#B, #C>>).arrow.optics.dsl/index(#B): arrow.optics/PTraversal<#A, #A, #C, #C> // arrow.optics.dsl/index|index@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> arrow.optics.match/it(arrow.optics/POptional<#A, #A, #B, #B>, arrow.optics/POptional<#A, #A, #C, #C>): arrow.optics/POptional<#A, #A, kotlin/Pair<#B, #C>, kotlin/Pair<#B, #C>> // arrow.optics.match/it|it(arrow.optics.POptional<0:0,0:0,0:1,0:1>;arrow.optics.POptional<0:0,0:0,0:2,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (#A).arrow.optics.match/matchOrElse(kotlin/Function0<#B>, kotlin/Function1<arrow.optics.match/MatchScope<#A, #B>, kotlin/Unit>): #B // arrow.optics.match/matchOrElse|matchOrElse@0:0(kotlin.Function0<0:1>;kotlin.Function1<arrow.optics.match.MatchScope<0:0,0:1>,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (#A).arrow.optics.match/matchOrThrow(kotlin/Function0<kotlin/Throwable> = ..., kotlin/Function1<arrow.optics.match/MatchScope<#A, #B>, kotlin/Unit>): #B // arrow.optics.match/matchOrThrow|matchOrThrow@0:0(kotlin.Function0<kotlin.Throwable>;kotlin.Function1<arrow.optics.match.MatchScope<0:0,0:1>,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.core.raise/Raise<arrow.optics.match/MatchNotFound>).arrow.optics.match/matchOrRaise(#A, kotlin/Function1<arrow.optics.match/MatchScope<#A, #B>, kotlin/Unit>): #B // arrow.optics.match/matchOrRaise|matchOrRaise@arrow.core.raise.Raise<arrow.optics.match.MatchNotFound>(0:0;kotlin.Function1<arrow.optics.match.MatchScope<0:0,0:1>,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PLens<#A, #A, kotlin.collections/Set<#B>, kotlin.collections/Set<#B>>).arrow.optics.dsl/at(#B): arrow.optics/PLens<#A, #A, kotlin/Boolean, kotlin/Boolean> // arrow.optics.dsl/at|at@arrow.optics.PLens<0:0,0:0,kotlin.collections.Set<0:1>,kotlin.collections.Set<0:1>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PLens<#B, #B, kotlin.collections/List<#A>, kotlin.collections/List<#A>>).arrow.optics/get(kotlin/Int): arrow.optics/POptional<#B, #B, #A, #A> // arrow.optics/get|get@arrow.optics.PLens<0:1,0:1,kotlin.collections.List<0:0>,kotlin.collections.List<0:0>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/ifEquals(#B): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.match/ifEquals|ifEquals@arrow.optics.POptional<0:0,0:0,0:1,0:1>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/suchThat(kotlin/Function1<#B, kotlin/Boolean>): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.match/suchThat|suchThat@arrow.optics.POptional<0:0,0:0,0:1,0:1>(kotlin.Function1<0:1,kotlin.Boolean>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/POptional<#A, #A, arrow.core/NonEmptyList<#B>, arrow.core/NonEmptyList<#B>>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.dsl/index|index@arrow.optics.POptional<0:0,0:0,arrow.core.NonEmptyList<0:1>,arrow.core.NonEmptyList<0:1>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/POptional<#A, #A, kotlin.collections/List<#B>, kotlin.collections/List<#B>>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.dsl/index|index@arrow.optics.POptional<0:0,0:0,kotlin.collections.List<0:1>,kotlin.collections.List<0:1>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/POptional<#A, #A, kotlin.collections/Set<#B>, kotlin.collections/Set<#B>>).arrow.optics.dsl/at(#B): arrow.optics/POptional<#A, #A, kotlin/Boolean, kotlin/Boolean> // arrow.optics.dsl/at|at@arrow.optics.POptional<0:0,0:0,kotlin.collections.Set<0:1>,kotlin.collections.Set<0:1>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/POptional<#A, #A, kotlin.sequences/Sequence<#B>, kotlin.sequences/Sequence<#B>>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.dsl/index|index@arrow.optics.POptional<0:0,0:0,kotlin.sequences.Sequence<0:1>,kotlin.sequences.Sequence<0:1>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, arrow.core/NonEmptyList<#B>, arrow.core/NonEmptyList<#B>>).arrow.optics.dsl/filter(kotlin/Function1<kotlin/Int, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, #B, #B> // arrow.optics.dsl/filter|filter@arrow.optics.PTraversal<0:0,0:0,arrow.core.NonEmptyList<0:1>,arrow.core.NonEmptyList<0:1>>(kotlin.Function1<kotlin.Int,kotlin.Boolean>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, arrow.core/NonEmptyList<#B>, arrow.core/NonEmptyList<#B>>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/PTraversal<#A, #A, #B, #B> // arrow.optics.dsl/index|index@arrow.optics.PTraversal<0:0,0:0,arrow.core.NonEmptyList<0:1>,arrow.core.NonEmptyList<0:1>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.collections/List<#B>, kotlin.collections/List<#B>>).arrow.optics.dsl/filter(kotlin/Function1<kotlin/Int, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, #B, #B> // arrow.optics.dsl/filter|filter@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.List<0:1>,kotlin.collections.List<0:1>>(kotlin.Function1<kotlin.Int,kotlin.Boolean>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.collections/List<#B>, kotlin.collections/List<#B>>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/PTraversal<#A, #A, #B, #B> // arrow.optics.dsl/index|index@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.List<0:1>,kotlin.collections.List<0:1>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.collections/Set<#B>, kotlin.collections/Set<#B>>).arrow.optics.dsl/at(#B): arrow.optics/PTraversal<#A, #A, kotlin/Boolean, kotlin/Boolean> // arrow.optics.dsl/at|at@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.Set<0:1>,kotlin.collections.Set<0:1>>(0:1){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.sequences/Sequence<#B>, kotlin.sequences/Sequence<#B>>).arrow.optics.dsl/filter(kotlin/Function1<kotlin/Int, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, #B, #B> // arrow.optics.dsl/filter|filter@arrow.optics.PTraversal<0:0,0:0,kotlin.sequences.Sequence<0:1>,kotlin.sequences.Sequence<0:1>>(kotlin.Function1<kotlin.Int,kotlin.Boolean>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin.sequences/Sequence<#B>, kotlin.sequences/Sequence<#B>>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/PTraversal<#A, #A, #B, #B> // arrow.optics.dsl/index|index@arrow.optics.PTraversal<0:0,0:0,kotlin.sequences.Sequence<0:1>,kotlin.sequences.Sequence<0:1>>(kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics.match/it(arrow.optics/POptional<#A, #A, #B, #B>): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.match/it|it(arrow.optics.POptional<0:0,0:0,0:1,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics/Optional(kotlin/Function1<#A, arrow.core/Option<#B>>, kotlin/Function2<#A, #B, #A>): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics/Optional|Optional(kotlin.Function1<0:0,arrow.core.Option<0:1>>;kotlin.Function2<0:0,0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> arrow.optics/Prism(kotlin/Function1<#A, arrow.core/Option<#B>>, kotlin/Function1<#B, #A>): arrow.optics/PPrism<#A, #A, #B, #B> // arrow.optics/Prism|Prism(kotlin.Function1<0:0,arrow.core.Option<0:1>>;kotlin.Function1<0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (#A).arrow.optics.match/matchUnit(kotlin/Function1<arrow.optics.match/MatchScope<#A, kotlin/Unit>, kotlin/Unit>) // arrow.optics.match/matchUnit|matchUnit@0:0(kotlin.Function1<arrow.optics.match.MatchScope<0:0,kotlin.Unit>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (#A).arrow.optics/cons(kotlin.collections/List<#A>): kotlin.collections/List<#A> // arrow.optics/cons|cons@0:0(kotlin.collections.List<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (#A).arrow.optics/copy(kotlin/Function1<arrow.optics/Copy<#A>, kotlin/Unit>): #A // arrow.optics/copy|copy@0:0(kotlin.Function1<arrow.optics.Copy<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (arrow.optics/POptional<#A, #A, kotlin/String, kotlin/String>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/POptional<#A, #A, kotlin/Char, kotlin/Char> // arrow.optics.dsl/index|index@arrow.optics.POptional<0:0,0:0,kotlin.String,kotlin.String>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin/String, kotlin/String>).arrow.optics.dsl/filter(kotlin/Function1<kotlin/Int, kotlin/Boolean>): arrow.optics/PTraversal<#A, #A, kotlin/Char, kotlin/Char> // arrow.optics.dsl/filter|filter@arrow.optics.PTraversal<0:0,0:0,kotlin.String,kotlin.String>(kotlin.Function1<kotlin.Int,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (arrow.optics/PTraversal<#A, #A, kotlin/String, kotlin/String>).arrow.optics.dsl/index(kotlin/Int): arrow.optics/PTraversal<#A, #A, kotlin/Char, kotlin/Char> // arrow.optics.dsl/index|index@arrow.optics.PTraversal<0:0,0:0,kotlin.String,kotlin.String>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/List<#A>).arrow.optics/snoc(#A): kotlin.collections/List<#A> // arrow.optics/snoc|snoc@kotlin.collections.List<0:0>(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/List<#A>).arrow.optics/uncons(): kotlin/Pair<#A, kotlin.collections/List<#A>>? // arrow.optics/uncons|uncons@kotlin.collections.List<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/List<#A>).arrow.optics/unsnoc(): kotlin/Pair<kotlin.collections/List<#A>, #A>? // arrow.optics/unsnoc|unsnoc@kotlin.collections.List<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> arrow.optics.match/equalsTo(#A): arrow.optics/POptional<#A, #A, #A, #A> // arrow.optics.match/equalsTo|equalsTo(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> arrow.optics.match/predicate(kotlin/Function1<#A, kotlin/Boolean>): arrow.optics/POptional<#A, #A, #A, #A> // arrow.optics.match/predicate|predicate(kotlin.Function1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any, #B: reified #A> arrow.optics.match/instanceOf(): arrow.optics/POptional<#A, #A, #B, #B> // arrow.optics.match/instanceOf|instanceOf(){0§<kotlin.Any>;1§<0:0>}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any, #C: reified #B> (arrow.optics/POptional<#A, #A, #B, #B>).arrow.optics.match/ifInstanceOf(): arrow.optics/POptional<#A, #A, #C, #C> // arrow.optics.match/ifInstanceOf|ifInstanceOf@arrow.optics.POptional<0:0,0:0,0:1,0:1>(){0§<kotlin.Any?>;1§<kotlin.Any>;2§<0:1>}[0]
final object arrow.optics/Every { // arrow.optics/Every|null[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> either(): arrow.optics/PTraversal<arrow.core/Either<#A1, #B1>, arrow.core/Either<#A1, #B1>, #B1, #B1> // arrow.optics/Every.either|either(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> map(): arrow.optics/PTraversal<kotlin.collections/Map<#A1, #B1>, kotlin.collections/Map<#A1, #B1>, #B1, #B1> // arrow.optics/Every.map|map(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> list(): arrow.optics/PTraversal<kotlin.collections/List<#A1>, kotlin.collections/List<#A1>, #A1, #A1> // arrow.optics/Every.list|list(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> nonEmptyList(): arrow.optics/PTraversal<arrow.core/NonEmptyList<#A1>, arrow.core/NonEmptyList<#A1>, #A1, #A1> // arrow.optics/Every.nonEmptyList|nonEmptyList(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> option(): arrow.optics/PTraversal<arrow.core/Option<#A1>, arrow.core/Option<#A1>, #A1, #A1> // arrow.optics/Every.option|option(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> pair(): arrow.optics/PTraversal<kotlin/Pair<#A1, #A1>, kotlin/Pair<#A1, #A1>, #A1, #A1> // arrow.optics/Every.pair|pair(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> sequence(): arrow.optics/PTraversal<kotlin.sequences/Sequence<#A1>, kotlin.sequences/Sequence<#A1>, #A1, #A1> // arrow.optics/Every.sequence|sequence(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> triple(): arrow.optics/PTraversal<kotlin/Triple<#A1, #A1, #A1>, kotlin/Triple<#A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.triple|triple(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple4(): arrow.optics/PTraversal<arrow.core/Tuple4<#A1, #A1, #A1, #A1>, arrow.core/Tuple4<#A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple4|tuple4(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple5(): arrow.optics/PTraversal<arrow.core/Tuple5<#A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple5<#A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple5|tuple5(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple6(): arrow.optics/PTraversal<arrow.core/Tuple6<#A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple6<#A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple6|tuple6(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple7(): arrow.optics/PTraversal<arrow.core/Tuple7<#A1, #A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple7<#A1, #A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple7|tuple7(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple8(): arrow.optics/PTraversal<arrow.core/Tuple8<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple8<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple8|tuple8(){0§<kotlin.Any?>}[0]
    final fun <#A1: kotlin/Any?> tuple9(): arrow.optics/PTraversal<arrow.core/Tuple9<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, arrow.core/Tuple9<#A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1, #A1>, #A1, #A1> // arrow.optics/Every.tuple9|tuple9(){0§<kotlin.Any?>}[0]
    final fun string(): arrow.optics/PTraversal<kotlin/String, kotlin/String, kotlin/Char, kotlin/Char> // arrow.optics/Every.string|string(){}[0]
}
final val arrow.optics.dsl/every // arrow.optics.dsl/every|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}every[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-every>(): arrow.optics/PTraversal<#A1, #A1, #C1, #C1> // arrow.optics.dsl/every.<get-every>|<get-every>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/every // arrow.optics.dsl/every|@arrow.optics.PTraversal<0:0,0:0,arrow.core.NonEmptyList<0:1>,arrow.core.NonEmptyList<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}every[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/NonEmptyList<#B1>, arrow.core/NonEmptyList<#B1>>).<get-every>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/every.<get-every>|<get-every>@arrow.optics.PTraversal<0:0,0:0,arrow.core.NonEmptyList<0:1>,arrow.core.NonEmptyList<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/every // arrow.optics.dsl/every|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}every[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Option<#B1>, arrow.core/Option<#B1>>).<get-every>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/every.<get-every>|<get-every>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/every // arrow.optics.dsl/every|@arrow.optics.PTraversal<0:0,0:0,kotlin.String,kotlin.String>{0§<kotlin.Any?>}every[0]
    final fun <#A1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, kotlin/String, kotlin/String>).<get-every>(): arrow.optics/PTraversal<#A1, #A1, kotlin/Char, kotlin/Char> // arrow.optics.dsl/every.<get-every>|<get-every>@arrow.optics.PTraversal<0:0,0:0,kotlin.String,kotlin.String>(){0§<kotlin.Any?>}[0]
final val arrow.optics.dsl/every // arrow.optics.dsl/every|@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.List<0:1>,kotlin.collections.List<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}every[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, kotlin.collections/List<#B1>, kotlin.collections/List<#B1>>).<get-every>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/every.<get-every>|<get-every>@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.List<0:1>,kotlin.collections.List<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/every // arrow.optics.dsl/every|@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}every[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, kotlin.collections/Map<#B1, #C1>, kotlin.collections/Map<#B1, #C1>>).<get-every>(): arrow.optics/PTraversal<#A1, #A1, #C1, #C1> // arrow.optics.dsl/every.<get-every>|<get-every>@arrow.optics.PTraversal<0:0,0:0,kotlin.collections.Map<0:1,0:2>,kotlin.collections.Map<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/every // arrow.optics.dsl/every|@arrow.optics.PTraversal<0:0,0:0,kotlin.sequences.Sequence<0:1>,kotlin.sequences.Sequence<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}every[0]
    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, kotlin.sequences/Sequence<#B1>, kotlin.sequences/Sequence<#B1>>).<get-every>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/every.<get-every>|<get-every>@arrow.optics.PTraversal<0:0,0:0,kotlin.sequences.Sequence<0:1>,kotlin.sequences.Sequence<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/left // arrow.optics.dsl/left|@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}left[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-left>(): arrow.optics/POptional<#A1, #A1, #B1, #B1> // arrow.optics.dsl/left.<get-left>|<get-left>@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/left // arrow.optics.dsl/left|@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}left[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PPrism<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-left>(): arrow.optics/PPrism<#A1, #A1, #B1, #B1> // arrow.optics.dsl/left.<get-left>|<get-left>@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/left // arrow.optics.dsl/left|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}left[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-left>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/left.<get-left>|<get-left>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/notNull // arrow.optics.dsl/notNull|@arrow.optics.POptional<0:0,0:0,0:1?,0:1?>{0§<kotlin.Any?>;1§<kotlin.Any?>}notNull[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, #B1?, #B1?>).<get-notNull>(): arrow.optics/POptional<#A1, #A1, #B1, #B1> // arrow.optics.dsl/notNull.<get-notNull>|<get-notNull>@arrow.optics.POptional<0:0,0:0,0:1?,0:1?>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/notNull // arrow.optics.dsl/notNull|@arrow.optics.PTraversal<0:0,0:0,0:1?,0:1?>{0§<kotlin.Any?>;1§<kotlin.Any?>}notNull[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, #B1?, #B1?>).<get-notNull>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/notNull.<get-notNull>|<get-notNull>@arrow.optics.PTraversal<0:0,0:0,0:1?,0:1?>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/right // arrow.optics.dsl/right|@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}right[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-right>(): arrow.optics/POptional<#A1, #A1, #C1, #C1> // arrow.optics.dsl/right.<get-right>|<get-right>@arrow.optics.POptional<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/right // arrow.optics.dsl/right|@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}right[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PPrism<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-right>(): arrow.optics/PPrism<#A1, #A1, #C1, #C1> // arrow.optics.dsl/right.<get-right>|<get-right>@arrow.optics.PPrism<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/right // arrow.optics.dsl/right|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>{0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}right[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?, #C1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Either<#B1, #C1>, arrow.core/Either<#B1, #C1>>).<get-right>(): arrow.optics/PTraversal<#A1, #A1, #C1, #C1> // arrow.optics.dsl/right.<get-right>|<get-right>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Either<0:1,0:2>,arrow.core.Either<0:1,0:2>>(){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final val arrow.optics.dsl/some // arrow.optics.dsl/some|@arrow.optics.POptional<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}some[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/POptional<#A1, #A1, arrow.core/Option<#B1>, arrow.core/Option<#B1>>).<get-some>(): arrow.optics/POptional<#A1, #A1, #B1, #B1> // arrow.optics.dsl/some.<get-some>|<get-some>@arrow.optics.POptional<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final val arrow.optics.dsl/some // arrow.optics.dsl/some|@arrow.optics.PTraversal<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>{0§<kotlin.Any?>;1§<kotlin.Any?>}some[0]
    final inline fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (arrow.optics/PTraversal<#A1, #A1, arrow.core/Option<#B1>, arrow.core/Option<#B1>>).<get-some>(): arrow.optics/PTraversal<#A1, #A1, #B1, #B1> // arrow.optics.dsl/some.<get-some>|<get-some>@arrow.optics.PTraversal<0:0,0:0,arrow.core.Option<0:1>,arrow.core.Option<0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
open annotation class arrow.optics/OpticsCopyMarker : kotlin/Annotation { // arrow.optics/OpticsCopyMarker|null[0]
    constructor <init>() // arrow.optics/OpticsCopyMarker.<init>|<init>(){}[0]
}
