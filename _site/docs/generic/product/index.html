<h2 id="arrow-generic">Arrow Generic</h2>

<p><code class="highlighter-rouge">arrow-generic</code> provides meta programming facilities over Product types like data classes, tuples, and heterogeneous lists; and Coproduct types like sealed classes.</p>

<h3 id="install">Install</h3>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">compile</span> <span class="s1">'io.arrow-kt:arrow-generic:$arrow_version'</span>
</code></pre></div></div>

<h3 id="features">Features</h3>

<h4 id="product">@product</h4>

<p>We refer to data classes, tuples, and heterogeneous lists as Product types because they all represent a container of typed values in which all those values need to be present.</p>

<p>That is to say that in the following data class both <code class="highlighter-rouge">balance</code> and <code class="highlighter-rouge">available</code> are properties of the <code class="highlighter-rouge">Account</code> class and both are typed and guaranteed to always be present within an <code class="highlighter-rouge">Account</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@product</span>
<span class="kd">data class</span> <span class="nc">Account</span><span class="p">(</span><span class="kd">val</span> <span class="py">balance</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">available</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">companion</span> <span class="k">object</span>
<span class="p">}</span>
</code></pre></div></div>

<p>All <code class="highlighter-rouge">@product</code> annotated data classes must include a <code class="highlighter-rouge">companion object</code> so that codegen can be properly expanded as extension functions to the companion.</p>

<p>Because of such properties we can automatically derive interesting behaviors from our data classes by using the <code class="highlighter-rouge">@product</code> annotation:</p>

<h4 id="extensions">Extensions</h4>

<p><code class="highlighter-rouge">@product</code> autmatically derives instances for <code class="highlighter-rouge">Semigroup</code> and <code class="highlighter-rouge">Monoid</code> supporting recursion in declared data types. In the example below we are able to <code class="highlighter-rouge">+</code> two <code class="highlighter-rouge">Account</code> objects because the instance <code class="highlighter-rouge">Int.semigroup()</code> is provided by Arrow.</p>

<h5 id="-operator">+ operator</h5>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.core.*</span>
<span class="k">import</span> <span class="nn">arrow.generic.*</span>

<span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">)</span> <span class="p">+</span> <span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">)</span>
<span class="c1">// Account(balance=2000, available=1800)</span>
</code></pre></div></div>

<h5 id="combineall">combineAll</h5>

<p><code class="highlighter-rouge">@product</code> enables also syntax over <code class="highlighter-rouge">List&lt;Account&gt;</code> to reduce <code class="highlighter-rouge">(List&lt;Account&gt;) -&gt; Account</code> automatically based also on the <code class="highlighter-rouge">Semigroup</code> instance, <code class="highlighter-rouge">@product</code> expects already defined instances for all contained data types which for most basic primitives Arrow already provides and for custom data types can be manually generated or automatically derived by Arrow with <code class="highlighter-rouge">@product</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">listOf</span><span class="p">(</span><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">),</span> <span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">)).</span><span class="n">combineAll</span><span class="p">()</span>
<span class="c1">// Account(balance=2000, available=1800)</span>
</code></pre></div></div>

<h5 id="tupled">tupled</h5>

<p><code class="highlighter-rouge">@product</code> enables <code class="highlighter-rouge">Account#tupled</code> and <code class="highlighter-rouge">Tuple2#toAccount</code> extensions automatically to go back and forth between the data class values to tuple representations such as <code class="highlighter-rouge">Tuple2</code> with the same arity and property types as those declared in the data class for all data classes with at least 2 properties.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">tupled</span><span class="p">()</span>
<span class="c1">// Tuple2(a=1000, b=900)</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">tupledLabeled</span><span class="p">()</span>
<span class="c1">// Tuple2(a=Tuple2(a=balance, b=1000), b=Tuple2(a=available, b=900))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Tuple2</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">toAccount</span><span class="p">()</span>
<span class="c1">// Account(balance=1000, available=900)</span>
</code></pre></div></div>

<h5 id="tohlist">toHList</h5>

<p><code class="highlighter-rouge">@product</code> enables <code class="highlighter-rouge">Account#toHList</code> and <code class="highlighter-rouge">HList2#toAccount</code> extensions automatically to go back and forth between the data class value to a heterogeneous list representation such as <code class="highlighter-rouge">HList2</code> with the same arity and property types as those declared in the data class regardless of the number of properties.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">toHList</span><span class="p">()</span>
<span class="c1">// HCons(head=1000, tail=HCons(head=900, tail=arrow.generic.HNil@6972a3c6))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">toHListLabeled</span><span class="p">()</span>
<span class="c1">// HCons(head=Tuple2(a=balance, b=1000), tail=HCons(head=Tuple2(a=available, b=900), tail=arrow.generic.HNil@6972a3c6))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hListOf</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">toAccount</span><span class="p">()</span>
<span class="c1">// Account(balance=1000, available=900)</span>
</code></pre></div></div>

<h5 id="applicativemapto___">Applicative#mapTo___</h5>

<p><code class="highlighter-rouge">@product</code> allows us map independent values in the context of any <code class="highlighter-rouge">Applicative</code> capable data type straight to the data class inside the data type context</p>

<p>In the examples below we can observe how 2 different <code class="highlighter-rouge">Int</code> properties are returned inside a type constructor such as <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">Try</code>, <code class="highlighter-rouge">Deferred</code> etc… and the automatically mapped to the shape of our <code class="highlighter-rouge">Account</code> data class removing all boilerplate from extracting the values from their context and returning an <code class="highlighter-rouge">Account</code> value in the same context.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">maybeBalance</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Option</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">maybeAvailable</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Option</span><span class="p">(</span><span class="m">900</span><span class="p">)</span>

<span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">mapToAccount</span><span class="p">(</span><span class="n">maybeBalance</span><span class="p">,</span> <span class="n">maybeAvailable</span><span class="p">)</span>
<span class="c1">// Some(Account(balance=1000, available=900))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">maybeBalance</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Option</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">maybeAvailable</span><span class="p">:</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">None</span>

<span class="n">Option</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">mapToAccount</span><span class="p">(</span><span class="n">maybeBalance</span><span class="p">,</span> <span class="n">maybeAvailable</span><span class="p">)</span>
<span class="c1">// None</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">tryBalance</span><span class="p">:</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Try</span> <span class="p">{</span> <span class="m">1000</span> <span class="p">}</span>
<span class="kd">val</span> <span class="py">tryAvailable</span><span class="p">:</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Try</span> <span class="p">{</span> <span class="m">900</span> <span class="p">}</span>

<span class="n">Try</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">mapToAccount</span><span class="p">(</span><span class="n">tryBalance</span><span class="p">,</span> <span class="n">tryAvailable</span><span class="p">)</span>
<span class="c1">// Success(value=Account(balance=1000, available=900))</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">tryBalance</span><span class="p">:</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Try</span> <span class="p">{</span> <span class="m">1000</span> <span class="p">}</span>
<span class="kd">val</span> <span class="py">tryAvailable</span><span class="p">:</span> <span class="n">Try</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Try</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">"BOOM"</span><span class="p">)</span> <span class="p">}</span>

<span class="n">Try</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">mapToAccount</span><span class="p">(</span><span class="n">tryBalance</span><span class="p">,</span> <span class="n">tryAvailable</span><span class="p">)</span>
<span class="c1">// Failure(exception=java.lang.RuntimeException: BOOM)</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">arrow.effects.*</span>
<span class="k">import</span> <span class="nn">kotlinx.coroutines.experimental.async</span>

<span class="kd">val</span> <span class="py">asyncBalance</span><span class="p">:</span> <span class="n">DeferredK</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="m">1000</span> <span class="p">}.</span><span class="n">k</span><span class="p">()</span>
<span class="kd">val</span> <span class="py">asyncAvailable</span><span class="p">:</span> <span class="n">DeferredK</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="m">900</span> <span class="p">}.</span><span class="n">k</span><span class="p">()</span>

<span class="n">DeferredK</span><span class="p">.</span><span class="n">applicative</span><span class="p">().</span><span class="n">mapToAccount</span><span class="p">(</span><span class="n">asyncBalance</span><span class="p">,</span> <span class="n">asyncAvailable</span><span class="p">)</span>
<span class="c1">// DeferredK(deferred=LazyDeferredCoroutine{New}@55a71bd3)</span>
</code></pre></div></div>

<h4 id="typeclass-instances">Typeclass instances</h4>

<h5 id="semigroup">Semigroup</h5>

<p>Combine and reduce a data class based on it’s internal properties reduction and combination properties as defined by their <code class="highlighter-rouge">Semigroup</code> instance.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">with</span><span class="p">(</span><span class="n">Account</span><span class="p">.</span><span class="n">semigroup</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">combine</span><span class="p">(</span><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// Account(balance=2000, available=1800)</span>
</code></pre></div></div>

<h5 id="monoid">Monoid</h5>

<p>Extends <code class="highlighter-rouge">Semigroup</code> by providing the concept of absent or empty value. It derives it’s empty value based on the empty value of each one of it’s contained properties.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">emptyAccount</span><span class="p">()</span>
<span class="c1">// Account(balance=0, available=0)</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Account</span><span class="p">.</span><span class="n">monoid</span><span class="p">().</span><span class="n">empty</span><span class="p">()</span>
<span class="c1">// Account(balance=0, available=0)</span>
</code></pre></div></div>

<h5 id="eq">Eq</h5>

<p>Structural equality in terms of <code class="highlighter-rouge">Eq</code>, a type class that represents equality.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">with</span><span class="p">(</span><span class="n">Account</span><span class="p">.</span><span class="n">eq</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">eqv</span><span class="p">(</span><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// true</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">with</span><span class="p">(</span><span class="n">Account</span><span class="p">.</span><span class="n">eq</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">neqv</span><span class="p">(</span><span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// false</span>
</code></pre></div></div>

<h5 id="show">Show</h5>

<p><code class="highlighter-rouge">toString</code> as a type class: <code class="highlighter-rouge">Show</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">with</span><span class="p">(</span><span class="n">Account</span><span class="p">.</span><span class="n">show</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Account</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">900</span><span class="p">).</span><span class="n">show</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// Account(balance=1000, available=900)</span>
</code></pre></div></div>

<h4 id="creating-instances-for-custom-properties">Creating instances for custom properties</h4>

<p>Sometimes you may be in need of creating type class instances for custom properties that Arrow does not provide by default.</p>

<p>In the following example our <code class="highlighter-rouge">Car</code> data class contains a <code class="highlighter-rouge">maxSpeed: Speed</code> property for a custom type.</p>

<p>Arrow can auto derive <code class="highlighter-rouge">Semigroup</code>, <code class="highlighter-rouge">Monoid</code>, <code class="highlighter-rouge">Eq</code> and <code class="highlighter-rouge">Show</code> for <code class="highlighter-rouge">Car</code> as long as we also have instances for <code class="highlighter-rouge">Speed</code>.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">Speed</span><span class="p">(</span><span class="kd">val</span> <span class="py">kmh</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">companion</span> <span class="k">object</span>
<span class="p">}</span>

<span class="n">@product</span>
<span class="kd">data class</span> <span class="nc">Car</span><span class="p">(</span><span class="kd">val</span> <span class="py">mod</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">speed</span><span class="p">:</span> <span class="n">Speed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">companion</span> <span class="k">object</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once we attempt to compile this we would get an error similar to the one below:</p>

<pre><code class="language-$xslt">:arrow-docs:compileKotlin: /home/raulraja/workspace/arrow/arrow/modules/docs/arrow-docs/build/generated/source/kaptKotlin/main/product.arrow.generic.car.kt: (60, 119): Unresolved reference.
</code></pre>

<p>This is because <code class="highlighter-rouge">Speed</code> is a data class not flagged as <code class="highlighter-rouge">@product</code>. Let’s fix that:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">@product</span>
<span class="kd">data class</span> <span class="nc">Speed</span><span class="p">(</span><span class="kd">val</span> <span class="py">kmh</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">companion</span> <span class="k">object</span>
<span class="p">}</span>

<span class="n">@product</span>
<span class="kd">data class</span> <span class="nc">Car</span><span class="p">(</span><span class="kd">val</span> <span class="py">mod</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">speed</span><span class="p">:</span> <span class="n">Speed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">companion</span> <span class="k">object</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The reason the code compiles now is that Arrow was able to complete the instance for <code class="highlighter-rouge">Car</code> once we proved we had one for <code class="highlighter-rouge">Speed</code>.</p>

<p>Now that <code class="highlighter-rouge">Speed</code> is also flagged as <code class="highlighter-rouge">@product</code> its <code class="highlighter-rouge">Semigroup</code>, <code class="highlighter-rouge">Monoid</code>, <code class="highlighter-rouge">Show</code> and <code class="highlighter-rouge">Eq</code> instances are available and visible in <code class="highlighter-rouge">Car</code></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Speed</span><span class="p">(</span><span class="m">50</span><span class="p">)</span> <span class="p">+</span> <span class="n">Speed</span><span class="p">(</span><span class="m">50</span><span class="p">)</span>
<span class="c1">// Speed(kmh=100)</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Car</span><span class="p">(</span><span class="n">Speed</span><span class="p">(</span><span class="m">50</span><span class="p">))</span> <span class="p">+</span> <span class="n">Car</span><span class="p">(</span><span class="n">Speed</span><span class="p">(</span><span class="m">50</span><span class="p">))</span>
<span class="c1">// Car(speed=Speed(kmh=100))</span>
</code></pre></div></div>
